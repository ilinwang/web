/*
  This file is to convert the network file generated by either 
  netgen or gridgen(the old DIMACS format) to the sp format which Goldberg use
  in splib
  usage:

    netgen2sp1 <network_file>

  it will overwrite the original network_file. Also, it will filter all
  duplicated arcs, only keep the one with min length.

  To compile:
    gcc -o netgen2sp1 netgen2sp1.c
    
  e.g., if you have use netgen or gridgen to create a min-cost network file
  named as netgen_100_4_1_1000_1.sp, you can convert it by
  
    netgen2sp1 netgen_100_4_1_1000_1.sp
  
  then the file netgen_100_4_1_1000_1.sp will be converted as a shortest path
  file.
  
----------------------------------------------------------------------------
by I-Lin Wang (ilin@alum.mit.edu)  2001.12.12
modified in 2007.06.15 by directly copying the input_name to be problem_name
----------------------------------------------------------------------------
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void read_number(FILE *input,int *has_problem_name,char *problem_name,
		 int *n_node);
void read_data(FILE *input,short int n_node,int *n_orig_arc,double *W);
void print_real_matrix(char *s,double *B, int mm, int nn);
/*------   definitions	  ------*/
#define M 99999999.	      /* a very high cost */
#define W( x, y ) (*((W)+((x)-1)*n_node+(y)-1))
#define DEFAULT_NAME "unknown"

int main(int argc, char *argv[])
{
  char input_name[300],problem_name[300];
  double *W;
  
  int n_node=0,n_orig_arc=0,has_problem_name=0;
  register int i,j;
  FILE *input,*output;

  strcpy(input_name,argv[1]);
  if ((input = fopen(input_name,"r"))==NULL)
    { printf("Cannot open input file, job skipped\n");exit(0); }
  
  /* read n_node, n_arc; n_arc may be checked later */
  read_number(input,&has_problem_name,problem_name,&n_node);
  /*
    printf("has_problem_name=%d\n",has_problem_name);
  if (has_problem_name==0)
    strcpy ( problem_name, strstr(input_name,"net"));
  printf("input_name=%s  problem_name=%s\n",input_name,problem_name);
  printf("%s\n",strchr(problem_name,'.'));
  exit(0);*/
  
  strcpy ( problem_name, input_name);

  /* allocate memory */
  if ((W=(double *)calloc((n_node*n_node),sizeof(double)))==NULL)
    { printf("Cannot allocate mem for cost Wij, job terminated\n");exit(0);}
  for (i=1;i<=n_node;i++)
    {
      for (j=1;j<=n_node;j++)
	W(i,j)=M;
      W(i,i)=0;
    }
  
  /* Read arc data, put into W */
  read_data(input,n_node,&n_orig_arc,W); 
  fclose(input);

  if ((output = fopen(input_name,"w"))==NULL)
    { printf("Cannot open input file, job skipped\n");exit(0); }
  /* output output */
  fprintf(output,"c This is converted from a network generated by netgen/gridgen\nc\n");
  fprintf(output,"t %s\np sp\t%d\t%d\nn\t%d\n",problem_name,n_node,n_orig_arc,
	  n_node);

  for (i=1;i<=n_node;i++)
    {
      for (j=1;j<i;j++)
	if (W(i,j)!=M)
	  fprintf(output,"a\t%d\t%d\t%f\n",i,j,W(i,j));
      
      for (j=i+1;j<=n_node;j++)
	if (W(i,j)!=M)
	  fprintf(output,"a\t%d\t%d\t%f\n",i,j,W(i,j));
    }
  free(W);
  fclose(output);
  return(0);
}
/*---------------------- read_number() ----------------------------------*/
void read_number(FILE *input,int *has_problem_name,char *problem_name,
		 int *n_node)
{ /* assume problem name(starting with "t" comes first,
     then "p" defines the size of the network */
  char c;
  char s[5];
  
  *has_problem_name=0;
  fscanf(input, "%c", &c);
  while ((c!='t')&&(c!='p'))
    {
      while(c!='\n')
	fscanf(input, "%c", &c);
      fscanf(input, "%c", &c);
    }
  if (c=='t')
    {
      fscanf(input, "%s", problem_name);
      *has_problem_name=1;
    }
  while (c!='p')
    {
      while(c!='\n')
	fscanf(input, "%c", &c);
      fscanf(input, "%c", &c);
    }
  fscanf(input, "%s %d", s, n_node);

  /*printf("n_node=%d  n_orig_arc=%d\n",n_node,n_orig_arc);exit(0);*/
}
/*---------------------- read_data() ----------------------------------*/
void read_data(FILE *input,short int n_node,int *n_orig_arc,double *W)
{
  char c;
  int from, to,is_neg_cost=0;
  double cost;
  
  while(fscanf(input, "%c", &c)!=EOF)
    {
      switch(c)
	{
	case 'n':
	case 'c':
	  break;
	case 'a':
	  fscanf(input, "%d %d %*s %*s %lf",&from,&to,&cost);
	  if (!is_neg_cost)
	    if (cost<0)
	      { printf("!!! some negative cost(%d,%d) < 0 !!\n",from,to);
	      is_neg_cost=1; }
	  
	  if (cost<0)  /* make all negative cost be positive */
	    cost=-cost;

	  if (W(from,to)==M)
	    (*n_orig_arc)++;
	  if (W(from,to) > cost)
	    W(from,to)=cost;   
	 
	  break;
	default:
	  break;
	}
    }

}
/*--------------- print_real_matrix() -----------------------------*/
void print_real_matrix(char *s,double *B, int mm, int nn)
{
  int i, j;
  printf("-- %s --\n",s);
 
  if (nn!=1)
    {
      for (i=1;i<=mm;i++)
        {
          for (j=1;j<=nn;j++)
            {
	      if (*(B+(i-1)*mm+(j-1))!=M)
		printf("%.0f ", *(B+(i-1)*mm+(j-1)));
	      else if (*(B+(i-1)*mm+(j-1))!=0)
		printf("M ");
	      else
		printf("0 ");
	    }
          printf("\n");
        }printf("-----]\n");
    }
  else
    {
      for (i=1;i<=mm;i++)
        printf("%f ", *(B+i));
      
      printf("\n-----]\n");
    }    
}
