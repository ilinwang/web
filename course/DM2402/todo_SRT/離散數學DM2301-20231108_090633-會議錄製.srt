1
00:00:00,000 --> 00:00:20,400
好 

2
00:00:24,400 --> 00:00:28,400
那我們現在很快地review BFS

3
00:00:28,400 --> 00:00:31,600
BFS是我們現在

4
00:00:31,600 --> 00:00:32,600
 

5
00:00:32,600 --> 00:00:36,500
最短路徑第一個講的演算法

6
00:00:36,500 --> 00:00:39,400
好 那它其實是適用在

7
00:00:39,400 --> 00:00:41,600
unit length的graph

8
00:00:41,600 --> 00:00:43,700
或者是unweighted graph

9
00:00:43,700 --> 00:00:45,400
也就是給你一個圖

10
00:00:45,400 --> 00:00:48,800
上面每一個edge的長度都是一樣的

11
00:00:48,800 --> 00:00:50,000
這樣的圖

12
00:00:50,000 --> 00:00:52,300
我如果給你起點

13
00:00:52,300 --> 00:00:56,000
給你起點請找出從起點到起點

14
00:00:56,000 --> 00:00:57,100
最短的路徑

15
00:00:57,100 --> 00:00:59,900
那這是一個unweighted的圖

16
00:00:59,900 --> 00:01:02,300
在這樣的圖要去找

17
00:01:02,300 --> 00:01:05,700
起點到起點最短路徑的作法之一

18
00:01:05,700 --> 00:01:07,800
就是用BFS

19
00:01:07,800 --> 00:01:10,400
它的名字是Breadth-First Search

20
00:01:10,400 --> 00:01:14,600
那中文翻成廣度優先的搜尋法

21
00:01:14,600 --> 00:01:17,200
搜尋到底在搜尋什麼

22
00:01:17,200 --> 00:01:19,600
它就是要搜尋從起點

23
00:01:19,600 --> 00:01:21,900
它可以touch到的有哪些點

24
00:01:21,900 --> 00:01:22,400
bye

25
00:01:22,400 --> 00:01:41,000
好 

26
00:01:41,000 --> 00:01:44,500
那從起點可以touch到有哪些點

27
00:01:44,500 --> 00:01:45,800
那這些事情

28
00:01:45,800 --> 00:01:49,700
我們如果按照它的演算法來看 

29
00:01:49,700 --> 00:01:51,800
那就是從起點出發

30
00:01:51,800 --> 00:01:54,400
然後它可以touch到的它就去touch

31
00:01:54,400 --> 00:01:56,600
 那依一個順序

32
00:01:56,600 --> 00:02:00,400
那等到你touch完你可以touch的呢

33
00:02:00,400 --> 00:02:03,000
 你就換新的起點

34
00:02:03,000 --> 00:02:06,600
那你新的起點 要從剛才

35
00:02:06,600 --> 00:02:10,600
剛touch過的裡面的某一個點開始 

36
00:02:10,600 --> 00:02:13,600
我們的手法就是先進先選 

37
00:02:13,600 --> 00:02:15,200
所以先被touch到的

38
00:02:15,200 --> 00:02:17,900
我就優先選來當新的起點 

39
00:02:17,900 --> 00:02:20,300
那比如說2然後它去touch到4

40
00:02:20,300 --> 00:02:22,300
然後再5又touch到6 

41
00:02:22,300 --> 00:02:24,600
那這樣子我就一層一層的

42
00:02:24,600 --> 00:02:27,800
從這邊可以touch到的

43
00:02:27,800 --> 00:02:29,800
這樣子去touch

44
00:02:29,800 --> 00:02:32,500
所以它一開始一定是一段edge

45
00:02:32,500 --> 00:02:33,600
可以到達的

46
00:02:33,600 --> 00:02:35,100
它就把它touch到

47
00:02:35,100 --> 00:02:37,300
再來是兩段edge可以到達的

48
00:02:37,300 --> 00:02:38,300
去touch到

49
00:02:38,300 --> 00:02:40,300
再來是三段edge可以到達的

50
00:02:40,300 --> 00:02:41,200
去touch到

51
00:02:41,200 --> 00:02:45,200
好 那可以證明出它這樣子touch的手法

52
00:02:45,500 --> 00:02:47,900
它如果可以從原點

53
00:02:47,900 --> 00:02:50,000
到達某一個點的話

54
00:02:50,000 --> 00:02:54,200
好 那它就逐一一層一層的去touch

55
00:02:54,200 --> 00:02:57,300
好 那如果有比較短的走法

56
00:02:57,300 --> 00:02:59,360
它一定可以這樣就可以touch到

57
00:02:59,360 --> 00:03:01,200
好 那這可以證明出

58
00:03:01,200 --> 00:03:03,100
 最短路徑

59
00:03:03,100 --> 00:03:05,600
 在這邊因為我們是unweighted graph

60
00:03:05,600 --> 00:03:07,600
好 所以 它的

61
00:03:07,600 --> 00:03:12,500
 整個路徑長度就等同於有幾段的

62
00:03:12,500 --> 00:03:13,900
arc 這樣子

63
00:03:14,100 --> 00:03:16,200
或幾段的edge是一樣的意思

64
00:03:16,200 --> 00:03:18,900
好 那這個 

65
00:03:18,900 --> 00:03:21,900
演算法它所花的時間好 

66
00:03:21,900 --> 00:03:25,300
那取決於你的資料結構是怎麼存的

67
00:03:25,300 --> 00:03:26,900
那當然我們現在

68
00:03:26,900 --> 00:03:28,900
老師都強調很多次了

69
00:03:28,900 --> 00:03:32,000
我們儘量用比較有效率的資料結構

70
00:03:32,000 --> 00:03:33,700
就是adjacency list

71
00:03:33,700 --> 00:03:36,100
那如果用adjacency list的話

72
00:03:36,100 --> 00:03:38,500
我們去存所有的edge

73
00:03:38,500 --> 00:03:41,000
用的就是m的一次方 

74
00:03:41,000 --> 00:03:42,600
而不是m平方

75
00:03:42,800 --> 00:03:44,800
m平方這是adjacency matrix

76
00:03:44,800 --> 00:03:46,900
好 那在我們

77
00:03:46,900 --> 00:03:50,400
BFS 的作法裡面有兩大步驟

78
00:03:50,400 --> 00:03:53,000
首先就是要選誰當起點

79
00:03:53,000 --> 00:03:56,300
再來就是要選從這個起點出發

80
00:03:56,300 --> 00:04:00,100
它要去scan 它所算出去的這些edge

81
00:04:00,100 --> 00:04:04,000
好 那每個起點只會被選一次

82
00:04:04,000 --> 00:04:07,000
因為它選它為什麼會被選

83
00:04:07,000 --> 00:04:08,700
就是它第一次被touch到

84
00:04:08,700 --> 00:04:10,300
它就放在那個籃子裡面

85
00:04:10,600 --> 00:04:13,000
它一旦從籃子裡面被拿出來之後

86
00:04:13,000 --> 00:04:14,100
它就刪除了

87
00:04:14,100 --> 00:04:15,500
等一下不會再進來

88
00:04:15,500 --> 00:04:18,800
好  因為在演算法的流程當中

89
00:04:18,800 --> 00:04:19,700
它之所以會進來

90
00:04:19,700 --> 00:04:21,500
就是因為它還沒被touch到

91
00:04:21,500 --> 00:04:22,600
所以既然它

92
00:04:22,600 --> 00:04:24,300
有被touch過了

93
00:04:24,300 --> 00:04:25,800
它當然就不會

94
00:04:25,800 --> 00:04:28,300
還沒被touch到

95
00:04:28,300 --> 00:04:29,600
所以它就不會再

96
00:04:29,600 --> 00:04:32,100
re-enter 那一個籃子

97
00:04:32,100 --> 00:04:34,900
那那個籃子我們用q來執行

98
00:04:34,900 --> 00:04:38,200
不過q在這邊是沒有扮演太大的角色

99
00:04:38,200 --> 00:04:40,500
所以每個

100
00:04:40,500 --> 00:04:44,300
vertex只會進到籃子一次又被刪掉

101
00:04:44,300 --> 00:04:46,100
那我們總共有n個

102
00:04:46,100 --> 00:04:47,300
vertex

103
00:04:47,300 --> 00:04:50,300
所以每次就刪一個每次刪一個

104
00:04:50,300 --> 00:04:51,100
刪到最後

105
00:04:51,100 --> 00:04:52,800
你頂多就刪了n次

106
00:04:52,800 --> 00:04:53,800
所以我們就知道

107
00:04:53,800 --> 00:04:56,500
你要去做vertex selection

108
00:04:56,500 --> 00:04:57,300
這件事情

109
00:04:57,300 --> 00:04:59,400
頂多就是n的一次方

110
00:04:59,400 --> 00:05:01,500
那你站在

111
00:05:01,500 --> 00:05:04,000
 某一個點被你選出來當

112
00:05:04,000 --> 00:05:05,500
起點的時候

113
00:05:05,700 --> 00:05:08,800
那 你去scan

114
00:05:08,800 --> 00:05:11,100
它所刪出去的這些edge

115
00:05:11,100 --> 00:05:14,600
因為我們假設用比較有效率的儲存方式

116
00:05:14,600 --> 00:05:16,800
所以它所花的時間

117
00:05:16,800 --> 00:05:19,500
就會跟它的out degree有關

118
00:05:19,500 --> 00:05:21,200
我們假設如果是有像圖的話

119
00:05:21,200 --> 00:05:22,900
 如果是無向圖就degree

120
00:05:22,900 --> 00:05:23,800
差不多意思 

121
00:05:23,800 --> 00:05:25,900
那它的out degree

122
00:05:25,900 --> 00:05:29,600
就它出去4條它就做了4次

123
00:05:29,600 --> 00:05:31,600
如果是3條就做3次

124
00:05:31,600 --> 00:05:32,800
那因為這個點

125
00:05:32,800 --> 00:05:35,500
等一下scan完它就功成身退了

126
00:05:35,500 --> 00:05:36,700
等一下也不會再進來

127
00:05:36,700 --> 00:05:38,900
好 所以這一段edge

128
00:05:38,900 --> 00:05:40,800
它只會被scan一次

129
00:05:40,800 --> 00:05:43,000
ok 好 

130
00:05:43,000 --> 00:05:45,400
那 所以overall

131
00:05:45,400 --> 00:05:49,300
我就把它所有的edge會被少的次數

132
00:05:49,300 --> 00:05:50,300
把它加總起來

133
00:05:50,300 --> 00:05:52,400
好 那大概就是

134
00:05:52,400 --> 00:05:54,300
  m的一次方

135
00:05:54,300 --> 00:05:56,600
這我們之前很早就有提過了

136
00:05:56,600 --> 00:05:57,400
好 

137
00:05:57,400 --> 00:06:00,200
那我這邊如果寫兩次

138
00:06:00,200 --> 00:06:03,400
跟一次的差別是在於 這個我是

139
00:06:03,600 --> 00:06:06,600
把它當成是undirected的圖

140
00:06:06,600 --> 00:06:09,400
那undirected你可以把它想像成

141
00:06:09,400 --> 00:06:10,800
類似雙向的

142
00:06:10,800 --> 00:06:13,000
好 所以它站在i的時候

143
00:06:13,000 --> 00:06:14,600
這一段會被它掃

144
00:06:14,600 --> 00:06:15,800
站在j的時候

145
00:06:15,800 --> 00:06:17,900
這一段也會被它掃之類的

146
00:06:17,900 --> 00:06:19,800
好 那不過無論如何

147
00:06:19,800 --> 00:06:22,900
都是以big O來講都是m的一次方

148
00:06:22,900 --> 00:06:24,700
好 所以這就是這邊的意思

149
00:06:24,700 --> 00:06:27,200
好 那 所以

150
00:06:27,200 --> 00:06:29,600
剛才講的第二個步驟

151
00:06:29,600 --> 00:06:31,100
叫做distance update

152
00:06:31,100 --> 00:06:32,700
好 它就是

153
00:06:32,800 --> 00:06:33,300
 

154
00:06:33,300 --> 00:06:36,700
我剛才講的站在一個點i

155
00:06:36,700 --> 00:06:39,400
去scan它的outgoing arcs

156
00:06:39,400 --> 00:06:40,200
這件事情

157
00:06:40,200 --> 00:06:42,900
好 那overall就是m的一次方

158
00:06:42,900 --> 00:06:45,300
所以兩個加總起來

159
00:06:45,300 --> 00:06:46,700
也就是m的一次方

160
00:06:46,700 --> 00:06:48,200
再加m的一次方

161
00:06:48,200 --> 00:06:51,300
那就m的一次方會dominate

162
00:06:51,300 --> 00:06:52,700
因此就是m的一次方

163
00:06:52,700 --> 00:06:55,000
所以我們後來就直接

164
00:06:55,000 --> 00:06:57,100
都是把它簡化成

165
00:06:57,100 --> 00:07:00,700
BFS它所花的時間就是m的一次方

166
00:07:01,200 --> 00:07:03,900
如果要寫的比較精確應該是m加n

167
00:07:03,900 --> 00:07:06,400
可是因為n通常都比m還要小

168
00:07:06,400 --> 00:07:08,000
好 所以我們就直接可以寫

169
00:07:08,000 --> 00:07:09,500
m的一次方這樣子

170
00:07:09,500 --> 00:07:12,200
那請問這是不是polynomial time

171
00:07:12,200 --> 00:07:14,700
當然是好 因為我們

172
00:07:14,700 --> 00:07:16,100
 把它想成

173
00:07:16,100 --> 00:07:17,300
給定一個圖

174
00:07:17,300 --> 00:07:19,900
它這個圖的problem size

175
00:07:19,900 --> 00:07:21,600
大概就是n跟m

176
00:07:21,600 --> 00:07:23,600
也就是幾個vertex

177
00:07:23,600 --> 00:07:24,700
幾個edge

178
00:07:24,700 --> 00:07:27,200
那現在我們所花的時間

179
00:07:27,200 --> 00:07:29,800
 要去判斷一個起點

180
00:07:29,800 --> 00:07:31,600
它可以touch到有哪些點

181
00:07:31,600 --> 00:07:32,500
這件事情

182
00:07:32,500 --> 00:07:34,600
所花的時間是m的一次方

183
00:07:34,600 --> 00:07:36,600
那就是polynomial

184
00:07:36,600 --> 00:07:39,400
time的一個估算

185
00:07:39,400 --> 00:07:40,300
好 

186
00:07:40,300 --> 00:07:45,000
那再來我們要講的是

187
00:07:45,000 --> 00:07:46,500
weighted graph

188
00:07:46,500 --> 00:07:49,000
好  在這個weighted graph這邊

189
00:07:49,000 --> 00:07:50,500
首先我先很快地

190
00:07:50,500 --> 00:07:52,700
總整 shorted path

191
00:07:52,700 --> 00:07:54,600
所會遇到的問題類型

192
00:07:54,600 --> 00:07:56,800
好 那 

193
00:07:56,800 --> 00:07:58,500
我們如果把它

194
00:07:59,400 --> 00:08:01,300
把我們所有的點 

195
00:08:01,300 --> 00:08:04,200
用成用一個nxn的矩陣

196
00:08:04,200 --> 00:08:05,600
好 這樣來代表

197
00:08:05,600 --> 00:08:09,000
 我要講的主要是要講說

198
00:08:09,000 --> 00:08:10,700
如果要算最短路徑的話

199
00:08:10,700 --> 00:08:12,100
一定是從一個i

200
00:08:12,100 --> 00:08:13,900
到一個j

201
00:08:13,900 --> 00:08:16,700
然後請問它的最短路徑是多少

202
00:08:16,700 --> 00:08:19,600
好 那因為i有n個

203
00:08:19,600 --> 00:08:20,400
j有n個

204
00:08:20,400 --> 00:08:22,600
所以我們可以簡化把它想成

205
00:08:22,600 --> 00:08:24,600
其實就是一個我們叫做

206
00:08:24,600 --> 00:08:26,100
distance matrix

207
00:08:26,100 --> 00:08:28,900
這個distance matrix要存的

208
00:08:29,200 --> 00:08:30,900
它的D_ij格

209
00:08:30,900 --> 00:08:33,600
就是要存從i當起點

210
00:08:33,600 --> 00:08:34,800
j當起點

211
00:08:34,800 --> 00:08:37,400
 它的最短路徑的長度

212
00:08:37,400 --> 00:08:39,200
我就把它放在那一格裡面

213
00:08:39,200 --> 00:08:40,800
請問這樣有幾格 

214
00:08:40,800 --> 00:08:43,000
答案當然是n平方格 

215
00:08:43,000 --> 00:08:44,700
嘿 如果它是

216
00:08:44,700 --> 00:08:47,600
 雙向應該說undirected的話

217
00:08:47,600 --> 00:08:48,700
它當然是對稱的

218
00:08:48,700 --> 00:08:51,300
也就是i到j的走法最短

219
00:08:51,300 --> 00:08:53,800
就等同於j到i的走法是最短

220
00:08:53,800 --> 00:08:55,900
那如果我們有方向性的話

221
00:08:55,900 --> 00:08:57,700
它不見得是對稱的好 

222
00:08:58,000 --> 00:09:00,100
好 不管那總之就是

223
00:09:00,100 --> 00:09:01,500
大概是n平方格

224
00:09:01,500 --> 00:09:04,100
好 那這看起來有一點像

225
00:09:04,100 --> 00:09:05,600
adjacency matrix那種感覺

226
00:09:05,600 --> 00:09:07,900
只不過它所儲存的是

227
00:09:07,900 --> 00:09:09,500
最短路徑的長度

228
00:09:09,500 --> 00:09:12,200
所以我們在求解最短路徑問題

229
00:09:12,200 --> 00:09:14,000
其實就是要去求解出

230
00:09:14,000 --> 00:09:16,300
這個D_ij這個matrix

231
00:09:16,300 --> 00:09:19,100
當然剛才有提過

232
00:09:19,100 --> 00:09:21,600
如果它是undirected graph的話

233
00:09:21,600 --> 00:09:22,500
它會是對稱的

234
00:09:22,500 --> 00:09:25,000
所以你根本就只要算上三角形

235
00:09:25,000 --> 00:09:27,000
或者是下三角形就夠了

236
00:09:27,100 --> 00:09:27,600
好 

237
00:09:27,600 --> 00:09:31,400
那最常見的最短路徑問題 

238
00:09:31,400 --> 00:09:34,400
通常我們叫做 single source shortest path

239
00:09:34,400 --> 00:09:37,600
或者是 single sink shortest path

240
00:09:37,600 --> 00:09:40,000
source 就是起點

241
00:09:40,000 --> 00:09:41,700
sink 就是起點

242
00:09:41,700 --> 00:09:43,600
有時候我們會用origin

243
00:09:43,600 --> 00:09:45,500
或destination來代表

244
00:09:45,500 --> 00:09:47,700
那single就是單一好 

245
00:09:47,700 --> 00:09:49,900
所以 我們最常用的

246
00:09:49,900 --> 00:09:52,600
我們剛才BFS其實已經demo過一次了

247
00:09:52,600 --> 00:09:55,200
就是我給定一個點當起點

248
00:09:55,500 --> 00:09:58,300
那我要去看它可以touch到哪些點

249
00:09:58,300 --> 00:10:01,700
那理論上就是把可以touch的都touch

250
00:10:01,700 --> 00:10:04,600
那如果所有的點其實它都是reachable

251
00:10:04,600 --> 00:10:07,900
也就是從s都可以抵達它的話

252
00:10:07,900 --> 00:10:10,000
那也就是大家都可以被touch到

253
00:10:10,000 --> 00:10:13,900
好 那你就得到了從s當起點

254
00:10:13,900 --> 00:10:16,100
去touch到所有其它點

255
00:10:16,100 --> 00:10:18,100
的最短的touch的方式

256
00:10:18,100 --> 00:10:20,600
那這個我們稱之為one to all

257
00:10:20,600 --> 00:10:24,700
好 那如果在這個D_ij這個matrix來看呢

258
00:10:24,700 --> 00:10:27,100
就等同於是我要去看這個row

259
00:10:27,100 --> 00:10:29,100
因為這就是第i個row

260
00:10:29,100 --> 00:10:31,500
那i到1 i到2 i到3

261
00:10:31,500 --> 00:10:33,300
i到4 i到5之類的好 

262
00:10:33,300 --> 00:10:36,700
就把這個row算出來這就是one to all

263
00:10:36,700 --> 00:10:38,500
那如果 

264
00:10:38,500 --> 00:10:42,700
one to all  就把它想成起點就是這個one

265
00:10:42,700 --> 00:10:45,100
這個all就是它的起點好 

266
00:10:45,100 --> 00:10:47,700
那如果起點是所有的點

267
00:10:47,700 --> 00:10:49,200
那起點是單一的點

268
00:10:49,200 --> 00:10:52,500
那也就是剛才提過的single sink

269
00:10:52,500 --> 00:10:53,700
shortest path

270
00:10:54,200 --> 00:10:57,000
那這個我們或簡稱為all to one

271
00:10:57,000 --> 00:10:59,300
好 那在這個distance matrix

272
00:10:59,300 --> 00:11:02,500
裡面它要算的就是單一的column

273
00:11:02,500 --> 00:11:04,000
好 因為這就是

274
00:11:04,000 --> 00:11:06,100
 第一到第四

275
00:11:06,100 --> 00:11:08,300
第二到第四第三到第四

276
00:11:08,300 --> 00:11:10,100
好 第五點到第

277
00:11:10,100 --> 00:11:12,100
 第五點到第四點這樣

278
00:11:12,100 --> 00:11:13,700
好 它的最短路徑

279
00:11:13,700 --> 00:11:17,900
好 那這是教科書最常做的

280
00:11:17,900 --> 00:11:20,500
大概都是one to all 或all to one

281
00:11:20,500 --> 00:11:22,900
那one to all 其實就是all to one

282
00:11:22,900 --> 00:11:24,300
好  

283
00:11:24,300 --> 00:11:26,900
可能大家會覺得哎方向顛倒 對

284
00:11:26,900 --> 00:11:28,600
 你可以把它想象成

285
00:11:28,600 --> 00:11:30,300
我其實如果把所有的

286
00:11:30,300 --> 00:11:32,100
 edge 的方向

287
00:11:32,100 --> 00:11:34,400
如果它有方向的話我把它反轉

288
00:11:34,400 --> 00:11:35,900
那這樣子one to all

289
00:11:35,900 --> 00:11:37,500
就會變成all to one了嗎

290
00:11:37,500 --> 00:11:38,700
不就一樣好 

291
00:11:38,700 --> 00:11:41,300
所以基本上one to all 跟all to one

292
00:11:41,300 --> 00:11:42,800
是在講同樣的事情

293
00:11:42,800 --> 00:11:44,400
它的演算法可以共用

294
00:11:44,400 --> 00:11:46,900
因為你只要把它的方向反轉就好 了

295
00:11:46,900 --> 00:11:50,540
好 好 那一般教科書最常用的

296
00:11:50,540 --> 00:11:52,700
 它都有一個假設

297
00:11:52,800 --> 00:11:55,000
就是我們假設它的edge的長度

298
00:11:55,000 --> 00:11:56,600
是non-negative

299
00:11:56,600 --> 00:11:59,800
那通常我們edge長度會用c_ij代表

300
00:11:59,800 --> 00:12:02,800
那也就是我們會假設c_ij是大一等於零

301
00:12:02,800 --> 00:12:06,100
 c_ij的意思就是我從i

302
00:12:06,100 --> 00:12:08,800
如果有一個edge直接去連j的話

303
00:12:08,800 --> 00:12:10,600
它的長度叫做c_ij

304
00:12:10,600 --> 00:12:12,600
那在前面的BFS

305
00:12:12,600 --> 00:12:16,100
我們等同於假設c_ij通通都為1

306
00:12:16,100 --> 00:12:17,200
這樣的意思

307
00:12:17,200 --> 00:12:19,100
好 那一般的問題

308
00:12:19,100 --> 00:12:21,900
的確我們的長度都是大一等於零

309
00:12:22,300 --> 00:12:23,600
譬如說距離

310
00:12:23,600 --> 00:12:24,900
譬如說時間

311
00:12:24,900 --> 00:12:27,500
好 那所以大家大概對於

312
00:12:27,500 --> 00:12:28,500
c_ij大一等於零

313
00:12:28,500 --> 00:12:29,600
大概沒有什麼疑慮

314
00:12:29,600 --> 00:12:32,200
那 一般的應用也

315
00:12:32,200 --> 00:12:33,700
的確都是像這樣子

316
00:12:33,700 --> 00:12:35,600
好 那不過三不五時

317
00:12:35,600 --> 00:12:38,200
我們可能會遇到c_ij有可能會負的

318
00:12:38,200 --> 00:12:41,700
通常那個概念可能是有正負的概念

319
00:12:41,700 --> 00:12:43,700
舉例來講金錢

320
00:12:43,700 --> 00:12:48,000
如果我從i走到j是要付錢的話

321
00:12:48,000 --> 00:12:51,200
那如果人家付我錢去走i到j

322
00:12:51,300 --> 00:12:53,200
那剛好 就一個是付錢

323
00:12:53,200 --> 00:12:54,500
一個是領錢

324
00:12:54,500 --> 00:12:56,200
付錢跟領錢的概念

325
00:12:56,200 --> 00:12:58,600
就是正負兩個是不一樣的

326
00:12:58,600 --> 00:13:01,300
ok 所以一般

327
00:13:01,300 --> 00:13:05,300
 時間或距離的確c_ij是大一等於零

328
00:13:05,300 --> 00:13:07,000
可是如果是金錢的概念

329
00:13:07,000 --> 00:13:08,600
就有可能有正有負

330
00:13:08,600 --> 00:13:10,200
那這有什麼差別

331
00:13:10,200 --> 00:13:11,800
有  

332
00:13:11,800 --> 00:13:13,600
如果會有正有負的話

333
00:13:13,600 --> 00:13:15,800
我們就稱之為它的edge的cost

334
00:13:15,800 --> 00:13:17,300
叫做general edge cost

335
00:13:17,300 --> 00:13:20,100
好 那 有什麼差別

336
00:13:20,400 --> 00:13:22,900
其實它的差別在於演算法的設計

337
00:13:22,900 --> 00:13:25,100
好  以問題來講

338
00:13:25,100 --> 00:13:27,400
沒有什麼太大的差別

339
00:13:27,400 --> 00:13:30,500
都是屬於polynomial time solvable

340
00:13:30,500 --> 00:13:32,400
其實它還有一個假設

341
00:13:32,400 --> 00:13:35,700
 也必須要有一個假設叫做

342
00:13:35,700 --> 00:13:38,200
no negative cycle

343
00:13:38,200 --> 00:13:41,300
ok 好  如果是正

344
00:13:41,300 --> 00:13:43,900
 有方向性的圖的話

345
00:13:43,900 --> 00:13:45,800
好 我們的所謂negative cycle

346
00:13:45,800 --> 00:13:46,500
就是像這樣子

347
00:13:46,500 --> 00:13:48,500
譬如說從1走到2

348
00:13:48,900 --> 00:13:50,300
是2塊錢

349
00:13:50,300 --> 00:13:52,700
從2走到3是3塊錢

350
00:13:52,700 --> 00:13:54,500
從3走到1呢

351
00:13:54,500 --> 00:13:56,500
我是-5-6塊錢

352
00:13:56,500 --> 00:13:59,100
這樣子我如果繞一圈

353
00:13:59,100 --> 00:14:00,800
我是不是變成-1

354
00:14:00,800 --> 00:14:02,500
因為2+3是5

355
00:14:02,500 --> 00:14:03,900
再減6就變-1

356
00:14:03,900 --> 00:14:05,700
好 那所以如果我們要

357
00:14:05,700 --> 00:14:08,200
把這個當做是長度

358
00:14:08,200 --> 00:14:09,700
當然這時候既然有負

359
00:14:09,700 --> 00:14:12,900
你用距離或時間就不太好 想像

360
00:14:12,900 --> 00:14:15,000
你可以把它想的是金錢的概念

361
00:14:15,000 --> 00:14:17,200
那如果我希望

362
00:14:17,500 --> 00:14:19,800
我的整個加總越小越好 的話

363
00:14:19,800 --> 00:14:21,700
它是不是就在這邊一直繞圈

364
00:14:21,700 --> 00:14:24,300
就會越繞越負的越多嗎

365
00:14:24,300 --> 00:14:26,500
好  不過當然你繞圈的話

366
00:14:26,500 --> 00:14:28,100
你就會讓每一個

367
00:14:28,100 --> 00:14:30,600
edge 或vertex

368
00:14:30,600 --> 00:14:32,600
你就會經過超過一次了

369
00:14:32,600 --> 00:14:34,600
 通常我們可能不希望這樣

370
00:14:34,600 --> 00:14:37,900
 問題是我們所設計的演算法

371
00:14:37,900 --> 00:14:40,300
待會如果我們有空會講

372
00:14:40,300 --> 00:14:43,000
的話講到的話叫做dex算法

373
00:14:43,000 --> 00:14:45,800
好 你如果follow它的邏輯去做

374
00:14:46,300 --> 00:14:50,400
它遇到像這種negative cycle的情況

375
00:14:50,400 --> 00:14:51,800
就會出狀況了

376
00:14:51,800 --> 00:14:54,000
因為根據它的邏輯

377
00:14:54,000 --> 00:14:57,300
它它有可能會讓它一直繞之類的

378
00:14:57,300 --> 00:14:59,800
好  其實它不會讓它一直繞

379
00:14:59,800 --> 00:15:01,800
不過它會讓它

380
00:15:01,800 --> 00:15:03,400
 算出來的

381
00:15:03,400 --> 00:15:05,100
會有問題

382
00:15:05,100 --> 00:15:06,700
也就是就不是最短

383
00:15:06,700 --> 00:15:07,700
好 ok

384
00:15:07,700 --> 00:15:10,200
所以通常我們在做最短路徑之前

385
00:15:10,200 --> 00:15:12,200
其實是要自己先小心

386
00:15:12,200 --> 00:15:13,200
檢驗

387
00:15:13,200 --> 00:15:14,800
請問給定的圖

388
00:15:14,900 --> 00:15:17,000
有沒有存在negative cycle

389
00:15:17,000 --> 00:15:19,000
如果有存在negative cycle

390
00:15:19,000 --> 00:15:21,200
以我們這門課目前

391
00:15:21,200 --> 00:15:23,400
 要教的呢

392
00:15:23,400 --> 00:15:27,500
大家就先把它想成我們完全無法處理

393
00:15:27,500 --> 00:15:29,000
好 好 

394
00:15:29,000 --> 00:15:31,400
所以如果老師給定的圖

395
00:15:31,400 --> 00:15:33,300
它包含negative cycle

396
00:15:33,300 --> 00:15:34,600
然後要你用

397
00:15:34,600 --> 00:15:37,300
 要你去計算最短路徑的話

398
00:15:37,300 --> 00:15:39,700
先天你大概就要有一個想法

399
00:15:39,700 --> 00:15:40,900
哎這個

400
00:15:40,900 --> 00:15:43,500
問題你可能要用

401
00:15:44,400 --> 00:15:45,200
窮舉法

402
00:15:45,200 --> 00:15:47,500
才能夠得到最佳解

403
00:15:47,500 --> 00:15:50,400
 原因是因為它有negative cycle

404
00:15:50,400 --> 00:15:52,800
哎哎真的那麼困難嗎

405
00:15:52,800 --> 00:15:54,700
是真的那麼困難 

406
00:15:54,700 --> 00:15:56,600
好 所以最短路徑

407
00:15:56,600 --> 00:15:57,200
 

408
00:15:57,200 --> 00:16:01,100
大家如果曾經在別門課有學過 

409
00:16:01,100 --> 00:16:02,700
通常它可能沒有特別強調

410
00:16:02,700 --> 00:16:05,000
不過其實就是老師這邊特別強調的

411
00:16:05,000 --> 00:16:07,300
就是它大部分都會假設

412
00:16:07,300 --> 00:16:09,600
它的長度是non-negative

413
00:16:09,600 --> 00:16:12,300
那也因為這樣的假設

414
00:16:12,800 --> 00:16:14,800
當然就不可能會有negative cycle

415
00:16:14,800 --> 00:16:17,300
好 所以它就不用去考慮

416
00:16:17,300 --> 00:16:18,600
那個negative cycle

417
00:16:18,600 --> 00:16:20,400
導致問題變難的問題

418
00:16:20,400 --> 00:16:23,100
好 所以當c_ij如果是大於等於零

419
00:16:23,100 --> 00:16:25,100
很容易可以證明出

420
00:16:25,100 --> 00:16:27,100
它這個問題是

421
00:16:27,100 --> 00:16:29,100
polynomial time solvable

422
00:16:29,100 --> 00:16:30,300
然後譬如說

423
00:16:30,300 --> 00:16:33,800
 等一下可能會講的Dijkstra

424
00:16:33,800 --> 00:16:34,700
演算法

425
00:16:34,700 --> 00:16:35,900
好 它就是針對

426
00:16:35,900 --> 00:16:37,900
這個問題去做的一個演算法

427
00:16:37,900 --> 00:16:39,200
是polynomial time

428
00:16:39,200 --> 00:16:42,500
那如果是有某些c_ij是負的

429
00:16:43,300 --> 00:16:46,500
好 那就有機會有可能會導致

430
00:16:46,500 --> 00:16:47,500
negative cycle

431
00:16:47,500 --> 00:16:50,600
 大家就記住只要有negative cycle

432
00:16:50,600 --> 00:16:52,300
我們就不能做就對了

433
00:16:52,300 --> 00:16:56,900
那萬一它有負的arc length

434
00:16:56,900 --> 00:16:59,800
可是它並沒有存在negative cycle

435
00:16:59,800 --> 00:17:00,900
這時候該怎麼辦

436
00:17:00,900 --> 00:17:04,900
這個時候有另外對應的作法

437
00:17:04,900 --> 00:17:06,900
好  這個時候的對應作法呢

438
00:17:06,900 --> 00:17:08,500
Dijkstra其實是不能用的

439
00:17:08,500 --> 00:17:11,400
好 所以這也是大家先有一個概念

440
00:17:12,100 --> 00:17:14,100
當你遇到的問題

441
00:17:14,100 --> 00:17:18,100
如果你已經確認沒有negative cycle

442
00:17:18,100 --> 00:17:20,300
可是裡面有某些arc

443
00:17:20,300 --> 00:17:21,900
它的長度是負的

444
00:17:21,900 --> 00:17:24,500
這個時候你不應該直接去用

445
00:17:24,500 --> 00:17:28,600
 最常被人家用的這個叫Dijkstra演算法

446
00:17:28,600 --> 00:17:30,600
你要用別種方法去算

447
00:17:30,600 --> 00:17:32,500
不過還是可以算

448
00:17:32,500 --> 00:17:34,800
而且也是polynomial time

449
00:17:34,800 --> 00:17:38,000
好 所以整個shortest path

450
00:17:38,000 --> 00:17:39,900
最主要大家就先記住

451
00:17:40,300 --> 00:17:42,500
無論如何不可以有negative cycle

452
00:17:42,500 --> 00:17:44,300
有negative cycle它就是困難了

453
00:17:44,300 --> 00:17:45,500
困難的意思就是

454
00:17:45,500 --> 00:17:47,500
目前沒有polynomial time的解法

455
00:17:47,500 --> 00:17:51,200
好 那通常我們要求它是要simple path

456
00:17:51,200 --> 00:17:52,700
也就是它不要讓它繞圈

457
00:17:52,700 --> 00:17:56,200
好 好 那如果有負的話

458
00:17:56,200 --> 00:17:57,400
我們不能夠用

459
00:17:57,400 --> 00:17:59,900
這些大於等於零的作法去做

460
00:17:59,900 --> 00:18:01,800
ok  如果是大於等於零

461
00:18:01,800 --> 00:18:04,600
那是我們最常見的也是最簡化的

462
00:18:04,600 --> 00:18:06,600
好  這大部分的書

463
00:18:06,600 --> 00:18:08,300
只會講這個部分而已

464
00:18:09,200 --> 00:18:12,300
好 那以上大概簡介了

465
00:18:12,300 --> 00:18:14,200
one to all all to one

466
00:18:14,200 --> 00:18:17,300
最常見的最難路徑的問題

467
00:18:17,300 --> 00:18:21,300
那再來這邊要講的是叫做

468
00:18:21,300 --> 00:18:22,900
all pair shortest path

469
00:18:22,900 --> 00:18:24,500
簡稱apsp

470
00:18:24,500 --> 00:18:28,000
或者是你可以把它理解為all to all

471
00:18:28,000 --> 00:18:31,600
它的意思就是所有的點當起點

472
00:18:31,600 --> 00:18:33,500
所有的點當起點

473
00:18:33,500 --> 00:18:36,200
簡單講就是把這個D_ij

474
00:18:36,200 --> 00:18:38,600
全部的i跟j通都算出來就對了

475
00:18:39,000 --> 00:18:40,900
好 也就是我現在想要計算

476
00:18:40,900 --> 00:18:43,800
所有的點到所有其它點的最短路徑

477
00:18:43,800 --> 00:18:46,400
長度還有怎麼走

478
00:18:46,400 --> 00:18:47,900
請告訴我該怎麼做

479
00:18:47,900 --> 00:18:50,200
這就是all to all

480
00:18:50,200 --> 00:18:52,000
的最短路徑問題

481
00:18:52,000 --> 00:18:54,300
那all to all 的最短路徑問題

482
00:18:54,300 --> 00:18:55,500
請問你要怎麼處理呢

483
00:18:55,500 --> 00:18:57,700
雖然說我們現在都還沒有講演算法

484
00:18:57,700 --> 00:19:00,000
不過從概念上可以理解

485
00:19:00,000 --> 00:19:03,300
哎如果我們會了one to all的話

486
00:19:03,300 --> 00:19:05,400
那我就把我的起點

487
00:19:05,400 --> 00:19:07,200
for 用一個for loop

488
00:19:07,200 --> 00:19:08,900
我改變我的起點就好 了

489
00:19:09,300 --> 00:19:10,400
譬如說我第一回合

490
00:19:10,400 --> 00:19:13,400
我就是起點設定 vertex 1

491
00:19:13,400 --> 00:19:14,700
one to all

492
00:19:14,700 --> 00:19:16,900
來第二回合 vertex 2

493
00:19:16,900 --> 00:19:17,700
one to all

494
00:19:17,700 --> 00:19:19,700
第三回合 vertex 3 當起點

495
00:19:19,700 --> 00:19:20,500
one to all

496
00:19:20,500 --> 00:19:22,100
one to all

497
00:19:22,100 --> 00:19:23,500
我這樣做了 n 次

498
00:19:23,500 --> 00:19:25,600
那我就處理 all to all

499
00:19:25,600 --> 00:19:28,800
對這就是第一個這邊所寫的

500
00:19:28,800 --> 00:19:31,600
我們重複的去執行

501
00:19:31,600 --> 00:19:33,400
single source shortest path

502
00:19:33,400 --> 00:19:36,600
重複的執行 one to all 執行了 n 次

503
00:19:36,600 --> 00:19:38,300
那你就做完了

504
00:19:39,100 --> 00:19:40,100
那就沒什麼大不了

505
00:19:40,100 --> 00:19:43,000
對的確好 好 

506
00:19:43,000 --> 00:19:45,600
那所以這個是大家可以想見

507
00:19:45,600 --> 00:19:47,400
雖然說我們都還沒有教各位

508
00:19:47,400 --> 00:19:48,900
one to all 怎麼做

509
00:19:48,900 --> 00:19:50,500
不過概念上 all to all

510
00:19:50,500 --> 00:19:52,000
就可以這樣處理

511
00:19:52,000 --> 00:19:53,400
這是沒有疑問的

512
00:19:53,400 --> 00:19:55,900
所以如果 one to all 是 polynomial time

513
00:19:55,900 --> 00:19:58,100
all to all 這樣從這個觀點

514
00:19:58,100 --> 00:20:00,300
當然也是 polynomial time

515
00:20:00,300 --> 00:20:02,700
因為它就是用一個 for loop

516
00:20:02,700 --> 00:20:05,900
把你的起點改了 n 次而已嗎

517
00:20:05,900 --> 00:20:08,100
好 所以如果本來是一個

518
00:20:08,300 --> 00:20:11,300
多項式我外面再乘以一個 n

519
00:20:11,300 --> 00:20:12,300
那只是

520
00:20:12,300 --> 00:20:15,500
一樣都是多項式

521
00:20:15,500 --> 00:20:16,700
ok 好 

522
00:20:16,700 --> 00:20:17,500
那

523
00:20:17,500 --> 00:20:20,500
所以這個是大家很容易可以理解

524
00:20:20,500 --> 00:20:21,600
好 

525
00:20:21,600 --> 00:20:24,800
那再來第二項的作法

526
00:20:24,800 --> 00:20:27,500
這個是從線性代數的角度

527
00:20:27,500 --> 00:20:28,600
其實不是線性代數

528
00:20:28,600 --> 00:20:30,100
應該講的比較精確

529
00:20:30,100 --> 00:20:32,600
是從代數的角度去求解它

530
00:20:32,600 --> 00:20:34,700
好 可以有另外一個作法

531
00:20:34,700 --> 00:20:37,000
這個叫做 Floyd-Warshall

532
00:20:37,000 --> 00:20:38,000
最常見的

533
00:20:38,000 --> 00:20:40,100
通常教科書可能會提的

534
00:20:40,100 --> 00:20:42,400
Floyd-Warshall 的作法

535
00:20:42,400 --> 00:20:42,800
好 

536
00:20:42,800 --> 00:20:44,000
那 Floyd-Warshall

537
00:20:44,000 --> 00:20:46,400
這當然 Floyd 跟 Warshall 就是兩個人

538
00:20:46,400 --> 00:20:48,300
那剛才講的 Dijkstra 也是一個人

539
00:20:48,300 --> 00:20:49,100
好 

540
00:20:49,100 --> 00:20:51,400
Dijkstra 是一個

541
00:20:51,400 --> 00:20:53,400
教授

542
00:20:53,400 --> 00:20:55,600
那我記得它好 像2000年出頭

543
00:20:55,600 --> 00:20:56,700
才剛過世

544
00:20:56,700 --> 00:20:58,700
那 Floyd 跟 Warshall 當然

545
00:20:58,700 --> 00:20:59,700
不是當然

546
00:20:59,700 --> 00:21:02,000
不過通常我記得好 像更早就過世了

547
00:21:02,000 --> 00:21:05,400
那這這些人都是1960年代

548
00:21:06,200 --> 00:21:08,200
把它們的方法發明出來的

549
00:21:08,200 --> 00:21:09,400
好 

550
00:21:09,400 --> 00:21:12,200
那這個代數形態的演算法

551
00:21:12,200 --> 00:21:14,800
也來求解最短路徑問題

552
00:21:14,800 --> 00:21:15,300
好 

553
00:21:15,300 --> 00:21:19,000
那這個我們之後會花一些時間去講

554
00:21:19,000 --> 00:21:19,700
好 

555
00:21:19,700 --> 00:21:22,600
那這個方法有一些它奇特的地方

556
00:21:22,600 --> 00:21:23,100
好 

557
00:21:23,100 --> 00:21:27,300
就是它的作法

558
00:21:27,300 --> 00:21:30,800
如果從寫程式的觀點來講

559
00:21:30,800 --> 00:21:32,100
還蠻簡化的

560
00:21:32,100 --> 00:21:32,600
好 

561
00:21:32,900 --> 00:21:36,400
那我們前面所講的用 for loop

562
00:21:36,400 --> 00:21:39,400
去變你的起點變了 n 次

563
00:21:39,400 --> 00:21:40,000
好 

564
00:21:40,000 --> 00:21:43,400
那我們當然是假設你已經知道

565
00:21:43,400 --> 00:21:45,000
如何去做 1 to O

566
00:21:45,000 --> 00:21:45,800
所以你才這樣做

567
00:21:45,800 --> 00:21:46,500
好 

568
00:21:46,500 --> 00:21:50,000
那如果是 FW 這個作法

569
00:21:50,000 --> 00:21:53,200
它其實是不需要從這個觀點去下手

570
00:21:53,200 --> 00:21:56,100
它是直接就把它算出來了

571
00:21:56,100 --> 00:21:58,400
那我這邊講的比較快的話

572
00:21:58,400 --> 00:21:59,900
可以把它想像成

573
00:22:00,400 --> 00:22:03,600
其實這個作法的概念有點類似

574
00:22:03,600 --> 00:22:05,000
我們給定一個

575
00:22:05,000 --> 00:22:06,400
矩陣

576
00:22:06,400 --> 00:22:08,100
square matrix

577
00:22:08,100 --> 00:22:09,600
方塊的矩陣

578
00:22:09,600 --> 00:22:11,200
好  n 乘 n 的矩陣

579
00:22:11,200 --> 00:22:13,400
好 更精確講其實就是我們的

580
00:22:13,400 --> 00:22:14,800
cost

581
00:22:14,800 --> 00:22:16,200
那個矩陣

582
00:22:16,200 --> 00:22:19,600
cost 那矩陣的意思就是大家把它想像成

583
00:22:19,600 --> 00:22:22,300
類似我們的 distance matrix

584
00:22:22,300 --> 00:22:23,000
只不過

585
00:22:23,000 --> 00:22:26,100
它裡面存的就是我們的 edge 的長度

586
00:22:26,100 --> 00:22:29,400
舉例來講如果 i 到 j 的 edge 長度是 2

587
00:22:29,500 --> 00:22:31,600
那你就把 ij 那個存 2

588
00:22:31,600 --> 00:22:34,400
那如果 i 沒有去連 j 的話

589
00:22:34,400 --> 00:22:37,000
那 ij 那個存的就是無限大

590
00:22:37,000 --> 00:22:38,800
好 因為它就沒有臉了

591
00:22:38,800 --> 00:22:41,100
好 所以這樣子的 matrix

592
00:22:41,100 --> 00:22:44,900
我們會把它命名叫做 measure matrix

593
00:22:44,900 --> 00:22:47,600
這個名詞之後還會再提

594
00:22:47,600 --> 00:22:52,000
好 那其實要算最短路徑

595
00:22:52,000 --> 00:22:53,400
D_ij

596
00:22:53,400 --> 00:22:55,400
可以被證明出

597
00:22:55,400 --> 00:22:57,100
它等同於

598
00:22:57,300 --> 00:23:01,200
某種程度的要把我們剛才這個 c_ij 的 matrix

599
00:23:01,200 --> 00:23:03,400
去取它的反矩陣的概念

600
00:23:03,400 --> 00:23:06,000
大概是這樣的概念

601
00:23:06,000 --> 00:23:08,200
好 那取反矩陣

602
00:23:08,200 --> 00:23:12,400
大家在高中或者是有修基本的現代住

603
00:23:12,400 --> 00:23:13,600
可能有學過了

604
00:23:13,600 --> 00:23:16,400
好 就給你一個 square matrix

605
00:23:16,400 --> 00:23:18,400
那請把它的反矩陣求出來

606
00:23:18,400 --> 00:23:20,000
請問你要用什麼方式去做

607
00:23:20,000 --> 00:23:22,500
好 概念類似像這樣子

608
00:23:22,500 --> 00:23:24,700
好 那這個我們到時候再提

609
00:23:24,700 --> 00:23:26,700
最後這個方法

610
00:23:27,200 --> 00:23:28,900
是又跟

611
00:23:28,900 --> 00:23:33,400
我們在大二下學期作業研究

612
00:23:33,400 --> 00:23:36,300
會學的線性規劃有關

613
00:23:36,300 --> 00:23:39,200
就是可以用線性規劃的方法來求

614
00:23:39,200 --> 00:23:41,100
最短路徑

615
00:23:41,100 --> 00:23:43,300
好 那這個我們就

616
00:23:43,300 --> 00:23:45,100
在這門課就不會提

617
00:23:45,100 --> 00:23:49,100
好 那一般我們其實遇到的是叫做

618
00:23:49,100 --> 00:23:50,900
multiple pair shorted paths

619
00:23:50,900 --> 00:23:52,300
意思就是

620
00:23:52,300 --> 00:23:55,200
我們可能也不需要知道全部了

621
00:23:55,200 --> 00:23:56,700
因為全部就是通殺

622
00:23:56,800 --> 00:24:00,700
好 那如果你只想要知道說某一個起點

623
00:24:00,700 --> 00:24:01,700
哎是這樣沒錯

624
00:24:01,700 --> 00:24:04,400
可是其實非常可能現實的情況

625
00:24:04,400 --> 00:24:06,600
我們可能是想要知道這一像這樣子

626
00:24:06,600 --> 00:24:09,100
比如說請告訴我1~2

627
00:24:09,100 --> 00:24:10,100
2~5

628
00:24:10,100 --> 00:24:11,700
3~1

629
00:24:11,700 --> 00:24:13,100
4~3

630
00:24:13,100 --> 00:24:14,300
5~4

631
00:24:14,300 --> 00:24:15,900
的最短路徑長度

632
00:24:15,900 --> 00:24:17,700
好 那總共

633
00:24:17,700 --> 00:24:20,000
以這個例子來講

634
00:24:20,000 --> 00:24:21,200
n=5

635
00:24:21,200 --> 00:24:24,300
好  假設對小線不不記的話

636
00:24:24,300 --> 00:24:25,900
我們總共有20格

637
00:24:25,900 --> 00:24:26,600
對不對

638
00:24:27,300 --> 00:24:28,300
應該說20個

639
00:24:28,300 --> 00:24:29,700
OD pair

640
00:24:29,700 --> 00:24:31,700
origin destination pair

641
00:24:31,700 --> 00:24:33,000
pair就是成雙成對

642
00:24:33,000 --> 00:24:35,100
好 起點的組合啦

643
00:24:35,100 --> 00:24:37,500
好 那我們有20個組合

644
00:24:37,500 --> 00:24:41,100
好 那我們有可能只想要知道其中的部分

645
00:24:41,100 --> 00:24:42,700
如果是O to O的話

646
00:24:42,700 --> 00:24:44,300
意思就是我要知道全部

647
00:24:44,300 --> 00:24:45,700
 如果是1 to O的話

648
00:24:45,700 --> 00:24:48,600
我就是等同於我要知道一個row或一個column

649
00:24:48,600 --> 00:24:50,300
那最常見的是

650
00:24:50,300 --> 00:24:53,200
我們只想要知道其中的某些OD pair

651
00:24:53,200 --> 00:24:54,400
這樣而已

652
00:24:54,400 --> 00:24:55,800
好 那

653
00:24:56,400 --> 00:24:57,500
那這個該怎麼辦

654
00:24:57,500 --> 00:24:59,800
當然這個作法你可以把它想成

655
00:24:59,800 --> 00:25:02,700
哎我可不可以用1 to 1做5次

656
00:25:02,700 --> 00:25:05,800
 1 to 1 1 to 1 1 to 1 1 to 1 1 to 1

657
00:25:05,800 --> 00:25:08,900
好 剛才老師還沒有特別講1 to 1

658
00:25:08,900 --> 00:25:11,100
好  什麼叫1 to 1

659
00:25:11,100 --> 00:25:13,800
就是我最常舉例一開始講的

660
00:25:13,800 --> 00:25:16,500
從一個起點到一個起點的最短路徑

661
00:25:16,500 --> 00:25:18,700
那1 to 1的處理方式

662
00:25:18,700 --> 00:25:21,200
通常就是用1 to O來處理

663
00:25:21,200 --> 00:25:24,900
ok  因為1 to O的作法

664
00:25:25,200 --> 00:25:27,600
好 或者大家現在因為我們還沒教

665
00:25:27,600 --> 00:25:29,700
可是你可以從BFS來想像

666
00:25:29,700 --> 00:25:31,700
我們在做BFS的時候

667
00:25:31,700 --> 00:25:34,600
我們剛才不是就是好 像從一個起點

668
00:25:34,600 --> 00:25:36,700
然後慢慢的這樣散出去對不對

669
00:25:36,700 --> 00:25:39,700
好 那譬如說像這邊我們從S

670
00:25:39,700 --> 00:25:41,700
然後就慢慢散出去慢慢散出去

671
00:25:41,700 --> 00:25:44,700
好 那舉例來講我現在如果想要知道

672
00:25:44,700 --> 00:25:47,400
哎起點是S終點是1

673
00:25:47,400 --> 00:25:49,200
的最短路徑請告訴我

674
00:25:49,200 --> 00:25:50,200
請問你該怎麼做

675
00:25:50,200 --> 00:25:52,800
好 那如果剛好 我給定的

676
00:25:53,000 --> 00:25:55,900
 這個圖每一段edge長度都一樣

677
00:25:55,900 --> 00:25:58,400
這個時候大家其實已經會做了

678
00:25:58,400 --> 00:26:01,300
因為它是屬於unit length graph

679
00:26:01,300 --> 00:26:04,000
所以我們直接用BFS就可以做

680
00:26:04,000 --> 00:26:07,700
那我們起點如果是S終點如果是1的話

681
00:26:07,700 --> 00:26:10,200
好 那你去做

682
00:26:10,200 --> 00:26:11,800
你就會發現哎

683
00:26:11,800 --> 00:26:15,100
就是根據這樣的順序 

684
00:26:15,100 --> 00:26:17,300
好 哎那當你把

685
00:26:17,300 --> 00:26:19,000
你的起點

686
00:26:19,000 --> 00:26:21,500
拿來當你的起點的時候

687
00:26:22,100 --> 00:26:26,200
好 那你其實就可以做結束做完了

688
00:26:26,200 --> 00:26:27,900
為什麼因為根據BFS

689
00:26:27,900 --> 00:26:30,000
我們剛才所講的那個道理

690
00:26:30,000 --> 00:26:33,500
好 它一旦被我選出來當起點

691
00:26:33,500 --> 00:26:35,100
它以後不會再被選了

692
00:26:35,100 --> 00:26:37,000
而且它已經被我touch到了

693
00:26:37,000 --> 00:26:39,900
等一下也不會有更短的touch方式了

694
00:26:39,900 --> 00:26:42,900
所以其實如果你的起點就在1的話

695
00:26:42,900 --> 00:26:46,000
你不用那麼笨的把後面這邊再繼續做

696
00:26:46,000 --> 00:26:47,400
好 你只要做

697
00:26:47,400 --> 00:26:49,800
所以其實以這邊來講就是你

698
00:26:49,800 --> 00:26:51,100
它是屬於第

699
00:26:51,600 --> 00:26:55,700
 除了原點之外的第五個點當起點的

700
00:26:55,700 --> 00:26:57,400
好 只要它當起點

701
00:26:57,400 --> 00:26:59,000
哎我就可以立馬停了

702
00:26:59,000 --> 00:27:01,400
後面這些都不用做了都不用做了

703
00:27:01,400 --> 00:27:03,000
因為你再怎麼做

704
00:27:03,000 --> 00:27:05,600
你不可能改變起點到

705
00:27:05,600 --> 00:27:08,400
起點1的最短路徑

706
00:27:08,400 --> 00:27:11,300
好 所以我剛才講的其實就是1 to 1

707
00:27:11,300 --> 00:27:12,600
意思就是

708
00:27:12,600 --> 00:27:15,600
我們要用1 to 1其實等同於用1 to all

709
00:27:15,600 --> 00:27:17,200
好 所以1 to all

710
00:27:17,200 --> 00:27:19,300
其實就跟1 to 1的作法就一樣

711
00:27:19,300 --> 00:27:21,000
 其實就是1 to all 的作法

712
00:27:21,500 --> 00:27:24,300
 它只不過在你的起點

713
00:27:24,300 --> 00:27:26,700
被你選來當起點的時候

714
00:27:26,700 --> 00:27:28,000
你就可以stop

715
00:27:28,000 --> 00:27:31,100
因為等一下再做下去

716
00:27:31,100 --> 00:27:33,300
也不可能找到更短的走法了

717
00:27:33,300 --> 00:27:34,600
好 概念是這樣

718
00:27:34,600 --> 00:27:37,000
好 所以回到剛才講的

719
00:27:37,000 --> 00:27:38,200
我們 

720
00:27:38,200 --> 00:27:40,500
就是如果要做

721
00:27:40,500 --> 00:27:41,800
這個1 to

722
00:27:41,800 --> 00:27:43,600
some to some的話

723
00:27:43,600 --> 00:27:46,100
你可以把它理解為很多的1 to 1

724
00:27:46,100 --> 00:27:50,700
好 那因為剛才講的你要處處理1 to 1

725
00:27:50,900 --> 00:27:52,800
其實是用1 to all來做

726
00:27:52,800 --> 00:27:54,900
嘿所以最壞的情況

727
00:27:54,900 --> 00:27:58,200
有可能你要處理這一個點

728
00:27:58,200 --> 00:27:59,400
是1 to 1對不對

729
00:27:59,400 --> 00:28:02,100
結果你用了整個1 to all去處理它

730
00:28:02,100 --> 00:28:04,000
你可能會有一點那麼說

731
00:28:04,000 --> 00:28:05,400
老師我就中間停就好 

732
00:28:05,400 --> 00:28:06,800
可是你對 沒錯

733
00:28:06,800 --> 00:28:08,100
可是問題是你怎麼知道

734
00:28:08,100 --> 00:28:09,800
這個點會不會是從1

735
00:28:09,800 --> 00:28:11,200
到的最後一個點

736
00:28:11,200 --> 00:28:12,200
有可能 

737
00:28:12,200 --> 00:28:13,600
如果是起點到

738
00:28:13,600 --> 00:28:15,500
如果這個點是最後一個點

739
00:28:15,500 --> 00:28:17,400
被你當起點了

740
00:28:17,400 --> 00:28:19,000
那你即使你知道說

741
00:28:19,000 --> 00:28:21,300
我可以中間遇到它當機我就停

742
00:28:21,300 --> 00:28:23,100
可是萬一它是最後一個起點的話

743
00:28:23,100 --> 00:28:24,600
那你還是要全做 

744
00:28:24,600 --> 00:28:27,300
好 所以剛才我的這種論述

745
00:28:27,300 --> 00:28:30,000
你可以用在我的每一個1 to 1

746
00:28:30,000 --> 00:28:32,000
所以在這種情況

747
00:28:32,000 --> 00:28:34,800
雖然說我其實只要20格

748
00:28:34,800 --> 00:28:37,500
裡面的某5格

749
00:28:37,500 --> 00:28:41,500
可是你有可能最好 的情況變成我通殺

750
00:28:41,500 --> 00:28:42,300
都要做

751
00:28:42,300 --> 00:28:44,400
但是這就有點浪費時間

752
00:28:44,400 --> 00:28:46,400
如果你用這種方法的話

753
00:28:46,400 --> 00:28:48,300
好  不過也沒辦法

754
00:28:48,400 --> 00:28:50,300
好 那 

755
00:28:50,300 --> 00:28:51,700
這是目前

756
00:28:51,700 --> 00:28:54,800
如果要處理some to some的話

757
00:28:54,800 --> 00:28:56,000
大概就這樣處理

758
00:28:56,000 --> 00:28:59,100
好 那我個人的博士論文

759
00:28:59,100 --> 00:29:00,700
其中一部分

760
00:29:00,700 --> 00:29:03,300
就是在做這個 mpsp

761
00:29:03,300 --> 00:29:06,800
 我有提出一個新的作法 

762
00:29:06,800 --> 00:29:09,900
那個作法可以稍微省一點時間 

763
00:29:09,900 --> 00:29:12,300
 不過這些都是屬於簡單問題

764
00:29:12,300 --> 00:29:16,800
好 那再來我們要講

765
00:29:16,900 --> 00:29:18,600
 的這幾頁 

766
00:29:18,600 --> 00:29:21,000
可能會比較對於一些同學

767
00:29:21,000 --> 00:29:22,800
會要花一些時間去理解

768
00:29:22,800 --> 00:29:24,300
那這邊

769
00:29:24,300 --> 00:29:27,900
 我會希望大家還是有辦法的話

770
00:29:27,900 --> 00:29:29,900
想辦法去把它理解

771
00:29:29,900 --> 00:29:32,100
然後 可以寫的出來

772
00:29:32,100 --> 00:29:34,500
好 那以下的幾頁

773
00:29:34,500 --> 00:29:36,600
就是前面我們有提過的

774
00:29:36,600 --> 00:29:41,300
 作業研究裡面我們會有教線性規劃

775
00:29:41,300 --> 00:29:43,100
好 那我們現在

776
00:29:43,100 --> 00:29:46,100
的1 to 0的問題

777
00:29:46,500 --> 00:29:49,100
我們想辦法用線性規劃

778
00:29:49,100 --> 00:29:51,700
去把它的數學式子寫出來

779
00:29:51,700 --> 00:29:53,360
那該怎麼寫

780
00:29:53,360 --> 00:29:55,800
答案就是長的這個樣子好 

781
00:29:55,800 --> 00:29:58,400
好 首先我們就先

782
00:29:58,400 --> 00:30:00,400
哎認清說

783
00:30:00,400 --> 00:30:03,400
在這個線性規劃的這個format呢

784
00:30:03,400 --> 00:30:04,900
我們有一個目標

785
00:30:04,900 --> 00:30:07,400
然後我們有一些限制式 

786
00:30:07,400 --> 00:30:08,400
我們的目標

787
00:30:08,400 --> 00:30:11,000
就是因為這是屬於最佳化的 

788
00:30:11,000 --> 00:30:13,900
我們的目標就是要整個路徑越短越好 

789
00:30:14,400 --> 00:30:18,000
那我們限制式就是你要最短的路徑

790
00:30:18,000 --> 00:30:19,900
可是你要遵守我的一些

791
00:30:19,900 --> 00:30:22,000
限制大概是這個意思

792
00:30:22,000 --> 00:30:23,600
好 那我們要用

793
00:30:23,600 --> 00:30:26,500
一些變數來達到我們的目的

794
00:30:26,500 --> 00:30:29,500
好 所以重點就是我們的變數是什麼意思

795
00:30:29,500 --> 00:30:33,000
了  那在這邊我先很快地講 

796
00:30:33,000 --> 00:30:36,100
那在這邊的變數就是這裡的x i j

797
00:30:36,100 --> 00:30:40,800
好 那你可以可以把它視為x i j 就是從i

798
00:30:40,800 --> 00:30:41,800
到j

799
00:30:41,800 --> 00:30:43,500
這一段edge

800
00:30:43,700 --> 00:30:46,200
 它到底

801
00:30:46,200 --> 00:30:48,600
流量是多少

802
00:30:48,600 --> 00:30:50,400
 什麼叫流量 

803
00:30:50,400 --> 00:30:52,600
所以比較容易理解的方式

804
00:30:52,600 --> 00:30:54,900
我建議大家先從one to one來理解

805
00:30:54,900 --> 00:30:56,700
好 假設我現在

806
00:30:56,700 --> 00:30:57,900
 起點

807
00:30:57,900 --> 00:31:00,900
是某一個點

808
00:31:00,900 --> 00:31:02,400
起點是某一個點

809
00:31:02,400 --> 00:31:05,500
那我要算起點到起點的最短路徑

810
00:31:05,500 --> 00:31:07,300
大家可以把它想像成

811
00:31:07,300 --> 00:31:09,600
我現在就是要送一個包裹

812
00:31:09,600 --> 00:31:11,100
從起點出發

813
00:31:11,200 --> 00:31:13,600
好 所以從起點出發的意思

814
00:31:13,600 --> 00:31:15,800
 在這邊我們會有一條限制式

815
00:31:15,800 --> 00:31:17,400
就是針對這個起點

816
00:31:17,400 --> 00:31:19,900
i 譬如說這個i就是我的起點

817
00:31:19,900 --> 00:31:20,700
好 那

818
00:31:20,700 --> 00:31:24,500
i 有很多條edge跟它相連有進有出

819
00:31:24,500 --> 00:31:26,500
然後那你可以把它視為說哎

820
00:31:26,500 --> 00:31:28,800
不管怎麼樣我就是要有

821
00:31:28,800 --> 00:31:32,600
一個東西要送出去就對了

822
00:31:32,600 --> 00:31:34,200
好 大概這個概念

823
00:31:34,200 --> 00:31:37,500
好 那所以剛才剛才你把它理解為

824
00:31:37,500 --> 00:31:40,300
從i到j的流量就等同於我

825
00:31:40,300 --> 00:31:43,200
沿著這一條送的送了幾單位出去

826
00:31:43,200 --> 00:31:44,000
這種概念

827
00:31:44,000 --> 00:31:46,000
好 所以如果你站在

828
00:31:46,000 --> 00:31:47,500
 某一個點i

829
00:31:47,500 --> 00:31:49,900
那有進有出嘛對不對

830
00:31:49,900 --> 00:31:51,900
那剛才老師有提過的

831
00:31:51,900 --> 00:31:53,500
哎就是你

832
00:31:53,500 --> 00:31:56,800
要送一單位出去

833
00:31:56,800 --> 00:31:58,900
所以我不管我進出是怎樣

834
00:31:58,900 --> 00:32:01,400
總之我的進流量就是要一單位了

835
00:32:01,400 --> 00:32:02,600
你可以這樣來理解

836
00:32:02,600 --> 00:32:05,400
好 那如果針對它的起點的話

837
00:32:05,400 --> 00:32:06,700
等同於它的

838
00:32:06,700 --> 00:32:09,400
進來的一定要一單位

839
00:32:09,600 --> 00:32:11,100
好 大家先把它想成說

840
00:32:11,100 --> 00:32:13,100
出去的就是正進來就是負

841
00:32:13,100 --> 00:32:16,000
好  當然其實那伴隨的是要去看

842
00:32:16,000 --> 00:32:17,400
這個限制式

843
00:32:17,400 --> 00:32:20,400
ok 限制式因為我們的寫法 

844
00:32:20,400 --> 00:32:21,960
當然我我假設大家都理解

845
00:32:21,960 --> 00:32:23,300
這叫submission 對不對

846
00:32:23,300 --> 00:32:25,260
好 這就是加總起來

847
00:32:25,260 --> 00:32:29,500
xij 好 那這是針對這是for each

848
00:32:29,500 --> 00:32:30,800
針對每一個i

849
00:32:30,800 --> 00:32:31,940
我站在i

850
00:32:31,940 --> 00:32:34,700
然後它會有出去的也會有進來的嘛

851
00:32:34,700 --> 00:32:36,140
好  你就把它想成

852
00:32:36,140 --> 00:32:38,100
我出去的這邊

853
00:32:38,560 --> 00:32:40,260
我要一單位出去就對了

854
00:32:40,260 --> 00:32:42,300
好  我進來的應該是

855
00:32:42,300 --> 00:32:43,200
 

856
00:32:43,200 --> 00:32:44,400
其實會是

857
00:32:44,400 --> 00:32:46,500
類似零單位啦不過

858
00:32:46,500 --> 00:32:47,860
不過無所謂 

859
00:32:47,860 --> 00:32:49,900
大家先直覺上先這樣來想

860
00:32:49,900 --> 00:32:52,460
那如果你大概可以

861
00:32:52,460 --> 00:32:53,700
 

862
00:32:53,700 --> 00:32:56,060
差不多理解它的出去

863
00:32:56,060 --> 00:32:57,660
那進來的話其實就雷同

864
00:32:57,660 --> 00:32:59,820
好 因為進來的你就看我

865
00:32:59,820 --> 00:33:01,200
同樣是站在i哦

866
00:33:01,200 --> 00:33:03,560
好 那你就是要某一個

867
00:33:03,560 --> 00:33:04,960
edge進來嘛

868
00:33:04,960 --> 00:33:07,400
 這個ij的話是出去的

869
00:33:07,400 --> 00:33:09,000
那ji的就進來的

870
00:33:09,000 --> 00:33:12,300
好 所以進來要有一單位的流量

871
00:33:12,300 --> 00:33:13,840
好 那因為

872
00:33:13,840 --> 00:33:15,060
如果這邊有一單位流量

873
00:33:15,060 --> 00:33:16,260
因為前面是負號

874
00:33:16,260 --> 00:33:17,360
所以這邊就變負1

875
00:33:17,360 --> 00:33:18,840
所以你可以這樣來理解

876
00:33:18,840 --> 00:33:20,940
那剩下的其它點 

877
00:33:20,940 --> 00:33:22,760
我們都稱之為轉運點

878
00:33:22,760 --> 00:33:24,700
所以它的進流量就是0

879
00:33:24,700 --> 00:33:26,660
好 那 

880
00:33:26,660 --> 00:33:28,360
我直接用這個圖

881
00:33:28,360 --> 00:33:31,200
這個例子來舉 好 好 

882
00:33:31,200 --> 00:33:33,440
譬如說我們現在如果給了

883
00:33:33,440 --> 00:33:34,640
這樣的一個圖

884
00:33:34,640 --> 00:33:36,500
好 那在這邊

885
00:33:36,840 --> 00:33:39,760
 跟前面的BFS不一樣

886
00:33:39,760 --> 00:33:41,860
主要在於我們已經要考慮

887
00:33:41,860 --> 00:33:43,300
weighted graph

888
00:33:43,300 --> 00:33:46,400
也就是我們真的有那個c_ij不是1

889
00:33:46,400 --> 00:33:49,400
好 所以像這裡大家看到這個數字

890
00:33:49,400 --> 00:33:50,800
就代表5-1

891
00:33:50,800 --> 00:33:52,500
這一段edge的長度是4

892
00:33:52,500 --> 00:33:54,900
然後1-4的長度是5

893
00:33:54,900 --> 00:33:57,060
好 那所以給定一個圖

894
00:33:57,060 --> 00:33:59,760
它的每一段的長度都告訴你了

895
00:33:59,760 --> 00:34:02,400
我現在要求1-5的最短路徑

896
00:34:02,400 --> 00:34:03,200
要怎麼算

897
00:34:03,200 --> 00:34:06,140
好 好 那這個作法呢

898
00:34:06,140 --> 00:34:07,300
你就把它想像成

899
00:34:07,300 --> 00:34:08,900
我們現在的這個x

900
00:34:08,900 --> 00:34:10,060
好 其實是

901
00:34:10,060 --> 00:34:12,740
 一個array

902
00:34:12,740 --> 00:34:14,440
 或者是一個vector

903
00:34:14,440 --> 00:34:17,560
好 那這裡加一個t是代表transpose的概念

904
00:34:17,560 --> 00:34:18,800
也就是轉字 

905
00:34:18,800 --> 00:34:21,560
因為因為大家應該有學過最基本的

906
00:34:21,560 --> 00:34:23,240
vector向量 

907
00:34:23,240 --> 00:34:26,640
就是你是row的vector還是column的vector

908
00:34:26,640 --> 00:34:29,040
好 那在這邊我簡化幾件

909
00:34:29,040 --> 00:34:31,440
我都是把它寫成column的vector

910
00:34:31,440 --> 00:34:34,200
也就是照理說我要寫x呢

911
00:34:34,200 --> 00:34:35,360
我要講的其實是

912
00:34:35,660 --> 00:34:37,140
x12

913
00:34:37,140 --> 00:34:39,540
x14

914
00:34:39,540 --> 00:34:42,760
x23這樣一路寫寫到x52

915
00:34:42,760 --> 00:34:44,500
這樣的一個column vector

916
00:34:44,500 --> 00:34:46,040
那因為空間的原因

917
00:34:46,040 --> 00:34:47,900
所以我我把它寫成

918
00:34:47,900 --> 00:34:50,300
transpose 那就是row vector

919
00:34:50,300 --> 00:34:52,400
好  這其實沒什麼大不了好 

920
00:34:52,400 --> 00:34:54,600
然後跟然後呢

921
00:34:54,600 --> 00:34:56,440
 我剛才主要要解釋的

922
00:34:56,440 --> 00:34:58,040
是在講它的constraint

923
00:34:58,040 --> 00:35:00,200
哎也就是大家把它想像一下

924
00:35:00,200 --> 00:35:02,360
這裡其實應該是一個column vector

925
00:35:02,360 --> 00:35:04,640
好 然後我第一條

926
00:35:05,000 --> 00:35:07,140
row乘以這個會等於1

927
00:35:07,140 --> 00:35:09,140
的意思就是

928
00:35:09,140 --> 00:35:12,340
x12加x14

929
00:35:12,340 --> 00:35:15,300
-x31-x51等於1

930
00:35:15,300 --> 00:35:16,700
好 我寫寫在這邊

931
00:35:16,700 --> 00:35:19,700
x12加x14-

932
00:35:19,700 --> 00:35:21,640
x31

933
00:35:21,640 --> 00:35:25,260
-x51會等於1

934
00:35:25,260 --> 00:35:26,660
這什麼意思

935
00:35:26,660 --> 00:35:29,100
這就是我正在1這個點

936
00:35:29,100 --> 00:35:30,740
那我們看看1這個點

937
00:35:30,740 --> 00:35:32,840
它是不是有進來的

938
00:35:32,840 --> 00:35:34,700
 因我們先講出去的

939
00:35:34,900 --> 00:35:36,100
出去的就是12

940
00:35:36,100 --> 00:35:37,260
好 這是2

941
00:35:37,260 --> 00:35:39,400
然後還有14出去嗎

942
00:35:39,400 --> 00:35:41,100
好 所以出去的流量

943
00:35:41,100 --> 00:35:42,560
是在這邊正

944
00:35:42,560 --> 00:35:44,900
那進來的就是3-1

945
00:35:44,900 --> 00:35:46,300
好 你看3-1

946
00:35:46,300 --> 00:35:48,600
然後還有5-1

947
00:35:48,600 --> 00:35:51,260
好 ok好 那這邊就是負

948
00:35:51,260 --> 00:35:53,940
所以出就是用正號在前面

949
00:35:53,940 --> 00:35:58,040
那 進就是用負號在前面

950
00:35:58,040 --> 00:35:59,740
那這樣出減進

951
00:35:59,740 --> 00:36:01,000
它要等於正1

952
00:36:01,000 --> 00:36:02,560
好 在講這個概念

953
00:36:02,560 --> 00:36:04,140
好 那我們再看第二條

954
00:36:04,980 --> 00:36:05,980
第二條這邊呢

955
00:36:05,980 --> 00:36:07,080
大家可以想像

956
00:36:07,080 --> 00:36:08,340
因為我們剛才是針對

957
00:36:08,340 --> 00:36:09,000
 

958
00:36:09,000 --> 00:36:10,340
node1

959
00:36:10,340 --> 00:36:12,140
 就是vertex1

960
00:36:12,140 --> 00:36:13,280
好 是這樣

961
00:36:13,280 --> 00:36:15,080
那我們現在如果針對vertex2

962
00:36:15,080 --> 00:36:16,200
來寫的話

963
00:36:16,200 --> 00:36:17,980
好 我們站在2

964
00:36:17,980 --> 00:36:19,600
你會發現哎

965
00:36:19,600 --> 00:36:21,880
它就是一個出三個進嗎

966
00:36:21,880 --> 00:36:24,940
所以一個出就x23來你看 哦

967
00:36:24,940 --> 00:36:26,340
哎這有兩個出嗎來

968
00:36:26,340 --> 00:36:29,040
一個出而已來

969
00:36:29,040 --> 00:36:31,600
x23對照規律是不是x23 

970
00:36:31,840 --> 00:36:34,140
ok好 所以x23

971
00:36:34,140 --> 00:36:36,600
然後其它都進嗎

972
00:36:36,600 --> 00:36:37,940
就是1-2

973
00:36:37,940 --> 00:36:39,540
5-2

974
00:36:39,540 --> 00:36:42,000
還有4-2來

975
00:36:42,000 --> 00:36:43,400
1-2這個是負1

976
00:36:43,400 --> 00:36:45,180
4-2是負1

977
00:36:45,180 --> 00:36:47,840
5-2是負1然後右手邊是0

978
00:36:47,840 --> 00:36:51,180
好  它概念其實就是等同於說 

979
00:36:51,180 --> 00:36:53,540
我現在有一單位的東西要從1

980
00:36:53,540 --> 00:36:56,140
然後要5要接收對不對

981
00:36:56,140 --> 00:36:57,940
好 5接收就是負1

982
00:36:57,940 --> 00:37:00,100
那1要出去就正1

983
00:37:00,600 --> 00:37:04,680
它的進流量對於vertex1來講是正1

984
00:37:04,680 --> 00:37:06,500
對vertex5來講是負1

985
00:37:06,500 --> 00:37:08,900
那其它的這個2 3 4呢

986
00:37:08,900 --> 00:37:11,300
它有點類似是轉運的概念

987
00:37:11,300 --> 00:37:13,700
就是事不關己 

988
00:37:13,700 --> 00:37:14,700
就是我

989
00:37:14,700 --> 00:37:16,680
我管你這個東西怎麼來怎麼去

990
00:37:16,680 --> 00:37:18,140
如果你會進到我的話

991
00:37:18,140 --> 00:37:18,800
你一定要出去

992
00:37:18,800 --> 00:37:21,180
因為我就不是你的destination

993
00:37:21,180 --> 00:37:23,300
 這就是為什麼這邊是0

994
00:37:23,300 --> 00:37:24,840
也就是你把它想的說

995
00:37:24,840 --> 00:37:26,340
我進來的

996
00:37:26,340 --> 00:37:28,240
跟我出去的

997
00:37:28,240 --> 00:37:30,240
它抵消掉

998
00:37:30,980 --> 00:37:32,420
好  ok 好 

999
00:37:32,420 --> 00:37:34,980
那所以用這樣的來理解

1000
00:37:34,980 --> 00:37:37,420
我的中間節點就是轉運點

1001
00:37:37,420 --> 00:37:38,540
 以這個例子

1002
00:37:38,540 --> 00:37:40,720
因為我們的起點是1中點是5

1003
00:37:40,720 --> 00:37:43,140
那就是2 3 4是轉運點 

1004
00:37:43,140 --> 00:37:44,340
所以這邊就寫成0

1005
00:37:44,340 --> 00:37:46,840
好 那以氣點來講氣就雷同

1006
00:37:46,840 --> 00:37:48,540
因為它最後要負1

1007
00:37:48,540 --> 00:37:50,180
那這個負1就來自於

1008
00:37:50,180 --> 00:37:52,540
 就它進到5嘛

1009
00:37:52,540 --> 00:37:54,020
那如果以這個圖來講

1010
00:37:54,020 --> 00:37:56,240
就可以進來就只有4 5這一條

1011
00:37:56,240 --> 00:37:59,380
 其它是5 1 5 2這都出去的

1012
00:37:59,480 --> 00:38:00,380
好  ok

1013
00:38:00,380 --> 00:38:02,020
 大部分的同學

1014
00:38:02,020 --> 00:38:03,420
可能一開始會有點納悶說

1015
00:38:03,420 --> 00:38:05,040
哎老師它既然就是進來

1016
00:38:05,040 --> 00:38:06,280
我就不要寫它出去 

1017
00:38:06,280 --> 00:38:07,680
怎麼或者是它如果是出去

1018
00:38:07,680 --> 00:38:08,920
我就不要寫進來 

1019
00:38:08,920 --> 00:38:10,840
好 哎我們這邊其實是

1020
00:38:10,840 --> 00:38:13,980
先給一個general的format

1021
00:38:13,980 --> 00:38:16,680
那反正你就照著這樣寫就對了

1022
00:38:16,680 --> 00:38:17,380
好 哎 

1023
00:38:17,380 --> 00:38:19,080
你剛才講的那個某種程度是沒錯

1024
00:38:19,080 --> 00:38:20,040
那是應該說

1025
00:38:20,040 --> 00:38:22,280
那是根據你的問題去客製化

1026
00:38:22,280 --> 00:38:25,180
可是 我們希望有一個一致的標準

1027
00:38:25,180 --> 00:38:26,680
好  這個一致的標準

1028
00:38:26,940 --> 00:38:29,540
 當我在處理1 to 1的時候可以處理

1029
00:38:29,540 --> 00:38:31,500
當我在處理1 to 2也可以處理

1030
00:38:31,500 --> 00:38:34,440
好 所以剛才我講了半天就是要去講

1031
00:38:34,440 --> 00:38:35,740
這一個matrix

1032
00:38:35,740 --> 00:38:37,500
然後這是right hand side

1033
00:38:37,500 --> 00:38:39,180
right hand side就右手邊的意思

1034
00:38:39,180 --> 00:38:41,340
好 那也就是對應到

1035
00:38:41,340 --> 00:38:42,880
我這邊

1036
00:38:42,880 --> 00:38:45,180
但我剛才的那個matrix

1037
00:38:45,180 --> 00:38:46,640
其實就跟這裡是一樣的哦

1038
00:38:46,640 --> 00:38:48,280
嘿好 這裡是什麼意思

1039
00:38:48,280 --> 00:38:48,580
嗯

1040
00:38:48,580 --> 00:38:50,540
我們剛才的圖

1041
00:38:50,540 --> 00:38:52,440
以剛才的圖總共有幾個點

1042
00:38:52,440 --> 00:38:54,740
12345有5個點

1043
00:38:54,740 --> 00:38:56,000
好 所以大家把它想成

1044
00:38:56,500 --> 00:38:59,880
哎我在這裡總共會有5條

1045
00:38:59,880 --> 00:39:02,880
因為 i 等於1你就會有一條

1046
00:39:02,880 --> 00:39:04,400
i 等於2也會有一條

1047
00:39:04,400 --> 00:39:05,600
i 等於3也會有一條

1048
00:39:05,600 --> 00:39:07,640
一直到 i 等於5總共就5條

1049
00:39:07,640 --> 00:39:11,080
好 那這個是x ij 代等於0

1050
00:39:11,080 --> 00:39:12,440
那x ij 是什麼

1051
00:39:12,440 --> 00:39:13,300
我再強調一次

1052
00:39:13,300 --> 00:39:15,540
x ij 就是代表從 i 到 j

1053
00:39:15,540 --> 00:39:17,200
的流量有多少

1054
00:39:17,200 --> 00:39:19,080
那如果是1 to 1的話

1055
00:39:19,080 --> 00:39:21,380
因為我們現在只有一個東西送出

1056
00:39:21,380 --> 00:39:24,040
好 那所以你也可以把它視為

1057
00:39:24,240 --> 00:39:27,340
好 像這一條edge有沒有被我選

1058
00:39:27,340 --> 00:39:29,740
如果有經過就是有被我選

1059
00:39:29,740 --> 00:39:31,680
因為它經過流量就是1嘛

1060
00:39:31,680 --> 00:39:33,120
好 如果有經過就是1

1061
00:39:33,120 --> 00:39:34,120
 沒有經過就是0

1062
00:39:34,120 --> 00:39:36,380
你也可以從這個觀點來看它

1063
00:39:36,380 --> 00:39:38,140
好 那

1064
00:39:38,140 --> 00:39:40,220
所以如果從這個觀點來看它就

1065
00:39:40,220 --> 00:39:42,280
就等同於是哎我站在1 

1066
00:39:42,280 --> 00:39:43,540
哎我可以出去的

1067
00:39:43,540 --> 00:39:45,520
這這些我就選一個嘛

1068
00:39:45,520 --> 00:39:46,880
 當然你可能就會覺得說

1069
00:39:46,880 --> 00:39:47,780
哎老師那進來

1070
00:39:47,780 --> 00:39:49,420
反正它不會進來我就定它為0

1071
00:39:49,420 --> 00:39:51,040
對啦反正它

1072
00:39:51,040 --> 00:39:53,740
其實做出來它也會告訴你它是0

1073
00:39:54,120 --> 00:39:55,820
好 那 

1074
00:39:55,820 --> 00:39:58,280
那中間的這些就進等於出進等於出

1075
00:39:58,280 --> 00:40:01,020
哎那 最後的氣點呢

1076
00:40:01,020 --> 00:40:03,580
就是它無論如何一定要有一個進來

1077
00:40:03,580 --> 00:40:04,740
好  

1078
00:40:04,740 --> 00:40:07,340
至於它出去的我們目視法知道它是0

1079
00:40:07,340 --> 00:40:08,380
不過先不管它

1080
00:40:08,380 --> 00:40:11,080
反正它就會給我算出來是0

1081
00:40:11,080 --> 00:40:14,620
好 那然後再來解釋這個叫做 

1082
00:40:14,620 --> 00:40:15,780
objective function

1083
00:40:15,780 --> 00:40:17,540
objective 就是目標函式

1084
00:40:17,540 --> 00:40:20,220
目標函式來想像一下

1085
00:40:20,220 --> 00:40:22,320
我現在我不知道我會怎麼走

1086
00:40:22,680 --> 00:40:24,880
 我一旦如果走第一段的話

1087
00:40:24,880 --> 00:40:26,840
它的長度就會被我catch到

1088
00:40:26,840 --> 00:40:28,440
如果走第二段的話

1089
00:40:28,440 --> 00:40:29,840
長度就會被我catch到

1090
00:40:29,840 --> 00:40:31,280
 什麼意思好 

1091
00:40:31,280 --> 00:40:32,780
我寫這樣的意思呢

1092
00:40:32,780 --> 00:40:35,240
就是大家想像一下這x是層開的

1093
00:40:35,240 --> 00:40:36,540
所以它objective

1094
00:40:36,540 --> 00:40:38,080
我們如果層開應該是長成

1095
00:40:38,080 --> 00:40:39,880
1x12

1096
00:40:39,880 --> 00:40:42,180
加上5x14

1097
00:40:42,180 --> 00:40:44,300
加上7x23

1098
00:40:44,300 --> 00:40:46,180
加上2x31

1099
00:40:46,180 --> 00:40:49,080
以此類推一直到最後就是6x52

1100
00:40:49,760 --> 00:40:52,660
那這整個式子

1101
00:40:52,660 --> 00:40:54,760
所代表的

1102
00:40:54,760 --> 00:40:57,340
就是它的總花費

1103
00:40:57,340 --> 00:40:58,900
因為你可以把它想成

1104
00:40:58,900 --> 00:41:00,500
我如果有經過我就有選

1105
00:41:00,500 --> 00:41:03,000
我如果有選我就catch到它的長度

1106
00:41:03,000 --> 00:41:06,100
所以這種model的方式

1107
00:41:06,100 --> 00:41:09,500
大家應該可以回想跟我們前面在講

1108
00:41:09,500 --> 00:41:10,400
非分化

1109
00:41:10,400 --> 00:41:11,860
大問題

1110
00:41:11,860 --> 00:41:14,160
你怎麼知道說我會選哪一個item

1111
00:41:14,160 --> 00:41:16,240
然後它是總重量要怎麼算

1112
00:41:16,240 --> 00:41:17,540
總價值要怎麼算

1113
00:41:17,540 --> 00:41:19,100
其實就是雷同的概念

1114
00:41:19,220 --> 00:41:22,220
好 那我需要我必須要把它minimize這樣

1115
00:41:22,220 --> 00:41:24,500
好 那所以這個

1116
00:41:24,500 --> 00:41:24,900
 

1117
00:41:24,900 --> 00:41:27,860
從這樣子就可以寫出它的

1118
00:41:27,860 --> 00:41:29,720
我們稱之為lp formulation

1119
00:41:29,720 --> 00:41:31,100
好 那

1120
00:41:31,100 --> 00:41:33,860
這個在講的比較精確一點

1121
00:41:33,860 --> 00:41:36,860
其實是叫做primal的lp formulation

1122
00:41:36,860 --> 00:41:39,360
好 那這邊有一個對應的dual

1123
00:41:39,360 --> 00:41:41,820
看來今天是沒有辦法講到這邊好 

1124
00:41:41,820 --> 00:41:42,760
好 那

1125
00:41:42,760 --> 00:41:43,400
 

1126
00:41:43,400 --> 00:41:46,120
所以我們可能就先focus在primal就好 

1127
00:41:46,120 --> 00:41:48,820
好 所以大家起碼這個要會寫

1128
00:41:49,120 --> 00:41:51,620
好 那剛才我們舉的例子是1 to 1

1129
00:41:51,620 --> 00:41:53,480
那如果是1 to 2的話

1130
00:41:53,480 --> 00:41:55,780
你可以把它想成它雷同的概念

1131
00:41:55,780 --> 00:41:58,220
現在如果要從起點是1

1132
00:41:58,220 --> 00:41:59,780
終點是2-5的話

1133
00:41:59,780 --> 00:42:01,320
其實大家可以把它想成

1134
00:42:01,320 --> 00:42:03,980
哎我從1送一單位給2

1135
00:42:03,980 --> 00:42:06,640
好 那這樣子是不是這邊正義不一

1136
00:42:06,640 --> 00:42:08,180
根據我1 to 1的概念嗎

1137
00:42:08,180 --> 00:42:09,920
那如果1要送給3呢

1138
00:42:09,920 --> 00:42:12,180
我就是再給它1再給它3

1139
00:42:12,180 --> 00:42:14,040
好 哎這兩個是不一樣的哦

1140
00:42:14,040 --> 00:42:15,820
因為1要送到2跟1要送到3

1141
00:42:15,820 --> 00:42:16,980
是兩個貨物嗎

1142
00:42:17,040 --> 00:42:19,000
好 所以你就可以用這樣來想

1143
00:42:19,000 --> 00:42:20,800
所以這樣的話1 to 2

1144
00:42:20,800 --> 00:42:23,240
其實其實就等同於好 多個1 to 1

1145
00:42:23,240 --> 00:42:25,100
把它疊加在一起的概念

1146
00:42:25,100 --> 00:42:27,740
好 那所以講白一點就是

1147
00:42:27,740 --> 00:42:29,200
我的2-5

1148
00:42:29,200 --> 00:42:31,060
我都要吸收一單位

1149
00:42:31,060 --> 00:42:33,100
總共要吸收四單位

1150
00:42:33,100 --> 00:42:37,400
這四單位完全從我的起點1來提供

1151
00:42:37,400 --> 00:42:39,500
所以1這邊就會有正4

1152
00:42:39,500 --> 00:42:41,900
那2 3 4 5都是負1

1153
00:42:41,900 --> 00:42:44,440
那寫出來就是寫成像這個樣子

1154
00:42:44,440 --> 00:42:45,800
也就是

1155
00:42:46,440 --> 00:42:48,200
這邊 right hand side

1156
00:42:48,200 --> 00:42:50,740
就是它的 supply or demand

1157
00:42:50,740 --> 00:42:52,000
的總量哦

1158
00:42:52,000 --> 00:42:54,660
ok supply or demand

1159
00:42:54,660 --> 00:42:55,960
好 那所以

1160
00:42:55,960 --> 00:42:58,400
像我這邊要提供四單位所以就正4

1161
00:42:58,400 --> 00:43:01,040
然後如果我需求一單位我就負1

1162
00:43:01,040 --> 00:43:02,660
好 這樣好 

1163
00:43:02,660 --> 00:43:03,500
那這是

1164
00:43:03,500 --> 00:43:07,040
vertex 1 2 3 4 5

1165
00:43:07,040 --> 00:43:09,040
然後中間的這一串

1166
00:43:09,040 --> 00:43:11,040
其實就跟我們剛才講的一樣

1167
00:43:11,040 --> 00:43:12,660
中間這一串在講的就是

1168
00:43:12,660 --> 00:43:14,340
它的連結的狀況

1169
00:43:15,120 --> 00:43:17,320
當然你要對準

1170
00:43:17,320 --> 00:43:18,600
你要對準你

1171
00:43:18,600 --> 00:43:20,000
每一個column

1172
00:43:20,000 --> 00:43:21,920
每一個column去對準就是一條

1173
00:43:21,920 --> 00:43:22,760
arc

1174
00:43:22,760 --> 00:43:23,960
一條edge

1175
00:43:23,960 --> 00:43:25,320
好 所以這就是為什麼

1176
00:43:25,320 --> 00:43:26,760
我這邊要把它對起來

1177
00:43:26,760 --> 00:43:28,320
我這邊對起來意思就是哎

1178
00:43:28,320 --> 00:43:30,920
第一個column呢就是1 2這一個

1179
00:43:30,920 --> 00:43:32,560
也就是edge 1 2

1180
00:43:32,560 --> 00:43:34,300
edge 1 4 edge 1 5

1181
00:43:34,300 --> 00:43:37,960
edge 2 3 3 1 3 4 4 1 4 3 5 1 5 2

1182
00:43:37,960 --> 00:43:39,800
我故意把它排序排好 

1183
00:43:39,800 --> 00:43:41,160
這樣比較整齊一點了

1184
00:43:41,160 --> 00:43:42,860
也就是一開頭的我先寫

1185
00:43:43,060 --> 00:43:44,420
然後在二開頭的寫

1186
00:43:44,420 --> 00:43:45,920
在三開頭的寫

1187
00:43:45,920 --> 00:43:47,420
在四開頭的寫

1188
00:43:47,420 --> 00:43:48,420
在五開頭的寫

1189
00:43:48,420 --> 00:43:49,760
我故意這樣寫了 

1190
00:43:49,760 --> 00:43:51,020
這樣大家比較整齊 

1191
00:43:51,020 --> 00:43:53,020
其實你愛什麼寫都隨便你 

1192
00:43:53,020 --> 00:43:54,260
好 那然後

1193
00:43:54,260 --> 00:43:57,820
然後呢 它的總花費

1194
00:43:57,820 --> 00:43:58,360
objective

1195
00:43:58,360 --> 00:44:00,260
我們剛才講了其實就完全一模一樣

1196
00:44:00,260 --> 00:44:02,280
因為如果我經過流量的話

1197
00:44:02,280 --> 00:44:03,360
就會被我catch到

1198
00:44:03,360 --> 00:44:04,620
好  

1199
00:44:04,620 --> 00:44:06,060
其實現在有可能

1200
00:44:06,060 --> 00:44:07,460
某一個edge

1201
00:44:07,460 --> 00:44:09,860
i j 它的流量可能超過1

1202
00:44:09,860 --> 00:44:10,680
因為為什麼

1203
00:44:10,680 --> 00:44:12,180
因為那就代表把它想成

1204
00:44:12,320 --> 00:44:13,720
它就是那個1 to 1

1205
00:44:13,720 --> 00:44:14,720
兩條1 to 1

1206
00:44:14,720 --> 00:44:16,060
如果重合在一起的話

1207
00:44:16,060 --> 00:44:17,360
那同樣的那一段

1208
00:44:17,360 --> 00:44:19,280
它的流量就變兩單位了嗎

1209
00:44:19,280 --> 00:44:21,060
 如果它有4

1210
00:44:21,060 --> 00:44:22,280
4個都經過

1211
00:44:22,280 --> 00:44:24,260
那那個流量就是四單位

1212
00:44:24,260 --> 00:44:25,680
好 總之

1213
00:44:25,680 --> 00:44:27,860
它的 format 還是長這個樣子

1214
00:44:27,860 --> 00:44:30,760
好 簡單講就是 c i j x i j

1215
00:44:30,760 --> 00:44:31,960
然後加總起來

1216
00:44:31,960 --> 00:44:34,120
我要把它 minimize

1217
00:44:34,120 --> 00:44:35,420
這樣嘿

1218
00:44:35,420 --> 00:44:37,220
所以這就 objective function

1219
00:44:37,220 --> 00:44:38,660
好 然後這裡

1220
00:44:38,660 --> 00:44:40,180
雖然我們剛才解釋了 line size

1221
00:44:40,180 --> 00:44:41,760
那裡面這個就跟剛才一樣

1222
00:44:41,760 --> 00:44:43,620
好 也就是你對準了

1223
00:44:43,620 --> 00:44:44,620
譬如說這是

1224
00:44:44,620 --> 00:44:46,220
edge 1 2

1225
00:44:46,220 --> 00:44:48,620
好 那我們先這樣寫來

1226
00:44:48,620 --> 00:44:51,060
若1代表 vertex 1

1227
00:44:51,060 --> 00:44:52,760
若2代表 vertex 2

1228
00:44:52,760 --> 00:44:54,720
所以在這邊總共有5個 vertex

1229
00:44:54,720 --> 00:44:55,860
就1 2 3 4 5嘛

1230
00:44:55,860 --> 00:44:58,160
好 那這裡如果是從

1231
00:44:58,160 --> 00:45:01,060
1到2的話那1這邊就正1

1232
00:45:01,060 --> 00:45:02,260
2這邊就負1

1233
00:45:02,260 --> 00:45:03,560
1到4的話

1234
00:45:03,560 --> 00:45:04,960
1這邊就正1

1235
00:45:04,960 --> 00:45:06,460
4這邊就負1

1236
00:45:06,460 --> 00:45:07,560
1到5的話

1237
00:45:07,560 --> 00:45:08,760
1這邊就正1

1238
00:45:08,760 --> 00:45:09,920
5這邊就負1

1239
00:45:09,920 --> 00:45:11,060
2到3的話

1240
00:45:11,220 --> 00:45:12,420
2這邊就正1

1241
00:45:12,420 --> 00:45:13,760
3這邊就負1

1242
00:45:13,760 --> 00:45:15,020
好 以此類推

1243
00:45:15,020 --> 00:45:16,120
4到3的話

1244
00:45:16,120 --> 00:45:17,460
4這邊就正1

1245
00:45:17,460 --> 00:45:18,580
3這邊就負1

1246
00:45:18,580 --> 00:45:19,660
所以你很快

1247
00:45:19,660 --> 00:45:21,880
也可以把這個 matrix 寫出來了

1248
00:45:21,880 --> 00:45:24,660
這就是我們所謂的 primal formulation

1249
00:45:24,660 --> 00:45:27,080
好 那寫完這個 formulation 可以怎樣

1250
00:45:27,080 --> 00:45:29,560
你可以把它餵給

1251
00:45:29,560 --> 00:45:31,780
相關的軟體

1252
00:45:31,780 --> 00:45:33,720
其實 excel 也可以做這件事情

1253
00:45:33,720 --> 00:45:35,620
好 然後它就給你做完了

1254
00:45:35,620 --> 00:45:37,680
這就是線性規劃

1255
00:45:37,680 --> 00:45:39,720
的 formulation

1256
00:45:39,960 --> 00:45:41,780
好 那我們剛才已經解釋完

1257
00:45:41,780 --> 00:45:43,460
one to one 跟 one to all

1258
00:45:43,460 --> 00:45:47,360
ok 好 那我們只解釋了 primal

1259
00:45:47,360 --> 00:45:50,260
 也就 do 我們這次就先不管它

1260
00:45:50,260 --> 00:45:51,880
好 好 那

1261
00:45:51,880 --> 00:45:54,060
 也就是這裡的 do

1262
00:45:54,060 --> 00:45:55,820
大家就可以先不管了

1263
00:45:55,820 --> 00:45:57,460
好  ok 好 

1264
00:45:57,460 --> 00:45:58,060
那

1265
00:45:58,060 --> 00:46:01,320
 所以今天大概我們就先到

1266
00:46:01,320 --> 00:46:02,620
到這邊為止

1267
00:46:02,620 --> 00:46:04,120
ok

1268
00:46:04,120 --> 00:46:10,120
謝謝大家

