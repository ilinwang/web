1
00:00:00,000 --> 00:00:08,580
好  那我們現在要講的是shortest path

2
00:00:08,580 --> 00:00:11,140
shortest path的簡寫sp

3
00:00:11,140 --> 00:00:16,540
那我們一開始先從比較簡化的圖形設定來看

4
00:00:16,540 --> 00:00:19,240
所謂的簡化圖形設定就是我們的圖

5
00:00:19,240 --> 00:00:21,980
它每一段edge i到j

6
00:00:21,980 --> 00:00:25,220
我們假設它長度是同樣的一單位

7
00:00:25,220 --> 00:00:27,540
所以在這種情況之下

8
00:00:27,540 --> 00:00:29,340
如果我畫了一個三角形

9
00:00:29,340 --> 00:00:31,780
那每一段的長度都是1到

10
00:00:31,780 --> 00:00:34,080
那我們把它稱作為unweighted graph

11
00:00:34,080 --> 00:00:36,580
或是叫做unit length graph

12
00:00:36,580 --> 00:00:40,340
在給定unit length graph的情況之下

13
00:00:40,340 --> 00:00:45,500
我們如果要尋找從一個點S到另外一個點T的連結方式

14
00:00:45,500 --> 00:00:47,060
所有連結方式裡面

15
00:00:47,060 --> 00:00:48,700
它的最短的走法

16
00:00:48,700 --> 00:00:51,340
它的意思就是你的包含

17
00:00:51,340 --> 00:00:55,540
path上面所包含的edge個數是最少個數的

18
00:00:55,540 --> 00:00:59,460
那我們把那個個數到底有幾條edge

19
00:00:59,460 --> 00:01:01,700
可以從S連到T最短有幾條

20
00:01:01,700 --> 00:01:03,340
我們稱之為distance

21
00:01:03,340 --> 00:01:06,940
這是我們針對unweighted graph所講的

22
00:01:06,940 --> 00:01:10,180
那我們之後在這個unweighted graph講完之後

23
00:01:10,180 --> 00:01:11,900
我們就會講weighted graph

24
00:01:11,900 --> 00:01:13,100
那如果是weighted graph

25
00:01:13,100 --> 00:01:17,620
大家把它想成譬如說這邊是1.4 2.3 10之類的

26
00:01:17,620 --> 00:01:20,500
那也就是我們的每一段edge

27
00:01:20,500 --> 00:01:22,540
它的長度不見得是一樣

28
00:01:22,540 --> 00:01:24,100
那稱之為weighted graph

29
00:01:24,100 --> 00:01:27,780
那我們一般所用的通常都是weighted graph

30
00:01:27,780 --> 00:01:30,260
不過我們先針對unweighted graph來講

31
00:01:30,260 --> 00:01:31,060
好 

32
00:01:31,060 --> 00:01:32,820
那所以weighted graph

33
00:01:32,820 --> 00:01:34,740
unweighted graph我大概已經講了

34
00:01:34,740 --> 00:01:36,780
那如果我這樣子講的話

35
00:01:36,780 --> 00:01:41,140
一條path的weight當然就是它的edge上面的weight的加總

36
00:01:41,140 --> 00:01:42,660
大概這個意思

37
00:01:42,660 --> 00:01:47,500
那你的path我們如果從I一直要走到J

38
00:01:47,500 --> 00:01:49,500
譬如說I要走到J

39
00:01:49,500 --> 00:01:53,500
然後假設中間經過了這個vertex

40
00:01:53,500 --> 00:01:58,060
K L P之類的

41
00:01:58,060 --> 00:02:00,660
那假設我的方向如果是從這邊走到這邊的話

42
00:02:00,660 --> 00:02:03,300
那就有一個前後關係

43
00:02:03,300 --> 00:02:05,420
那我們前後關係的定義

44
00:02:05,420 --> 00:02:08,340
我們就用predecessor跟successor來講

45
00:02:08,340 --> 00:02:12,780
predecessor講的指的是說某一個點它的前面那個點

46
00:02:12,780 --> 00:02:15,620
所以譬如說如果我用這個方向來講的話

47
00:02:15,620 --> 00:02:17,820
我們的predecessor的K

48
00:02:17,820 --> 00:02:19,380
如果K是我的input

49
00:02:19,380 --> 00:02:20,860
它的前面那個點

50
00:02:20,860 --> 00:02:22,060
那就是I

51
00:02:22,060 --> 00:02:24,300
那P的前面那個點

52
00:02:24,300 --> 00:02:25,300
那就是L

53
00:02:25,300 --> 00:02:27,300
那J的前面那個點就是P

54
00:02:27,300 --> 00:02:28,300
這樣大家可以理解

55
00:02:28,300 --> 00:02:30,540
那successor剛好 是顛倒的概念

56
00:02:30,540 --> 00:02:31,900
也就是它的後面那個點

57
00:02:31,900 --> 00:02:33,900
所以譬如說我的successor

58
00:02:33,900 --> 00:02:35,900
I的successor

59
00:02:35,900 --> 00:02:37,900
I的後面那個點就是K

60
00:02:37,900 --> 00:02:40,540
那L的後面那個點就是P

61
00:02:40,540 --> 00:02:44,180
那所以剛好 P的predecessor是L

62
00:02:44,180 --> 00:02:45,860
L的successor是P

63
00:02:45,860 --> 00:02:47,860
就互為顛倒

64
00:02:47,860 --> 00:02:49,860
這個應該很容易可以理解

65
00:02:49,860 --> 00:02:52,540
所以我們可以經由predecessor跟successor

66
00:02:52,540 --> 00:02:55,300
來串聯整條path的前後關係

67
00:02:55,300 --> 00:02:57,300
這樣才不會順序搞亂

68
00:02:57,300 --> 00:02:58,300
ok

69
00:02:58,300 --> 00:03:00,900
那所以當我們在記錄我們的path

70
00:03:00,900 --> 00:03:02,300
有方向性的時候

71
00:03:02,300 --> 00:03:05,860
最好 我們都可以把predecessor還有successor順便就記錄

72
00:03:05,860 --> 00:03:08,380
這樣我們就可以把它跟蹤出來

73
00:03:08,380 --> 00:03:10,740
跟蹤的英文叫做trace

74
00:03:10,740 --> 00:03:12,740
我們可以把它整個trace出來這樣子

75
00:03:12,740 --> 00:03:13,740
好 

76
00:03:13,740 --> 00:03:16,620
那如果你頭跟尾的話

77
00:03:16,620 --> 00:03:17,620
譬如說以頭

78
00:03:17,620 --> 00:03:19,100
如果是從I出發的話

79
00:03:19,100 --> 00:03:21,100
請問I的前面有人嗎?沒有

80
00:03:21,100 --> 00:03:22,100
那我們稱之為no

81
00:03:22,100 --> 00:03:23,700
請問J的後面有人嗎?

82
00:03:23,700 --> 00:03:24,980
如果J是最後一個點

83
00:03:24,980 --> 00:03:25,700
J的後面沒有

84
00:03:25,700 --> 00:03:26,700
我們稱之為no

85
00:03:26,700 --> 00:03:28,700
這個就跟之前

86
00:03:28,700 --> 00:03:30,700
大家在定義array

87
00:03:30,700 --> 00:03:32,700
這個是一樣的概念

88
00:03:32,700 --> 00:03:33,700
好 

89
00:03:33,700 --> 00:03:37,700
那我們現在就先針對unweighted或unigraph

90
00:03:37,700 --> 00:03:39,700
來做說明

91
00:03:39,700 --> 00:03:40,700
好 

92
00:03:40,700 --> 00:03:44,700
那我們剛才已經解釋過什麼是unigraph了

93
00:03:44,700 --> 00:03:47,700
意思就是我們的edge的長度大家都一樣

94
00:03:47,700 --> 00:03:48,700
好 

95
00:03:48,700 --> 00:03:50,700
那我們現在來定義

96
00:03:50,700 --> 00:03:52,700
1 to 1的shortest path

97
00:03:52,700 --> 00:03:54,700
1 to 1的意思就是

98
00:03:54,700 --> 00:03:57,700
單一個起點到單一個起點的意思

99
00:03:57,700 --> 00:03:58,700
好 

100
00:03:58,700 --> 00:04:01,700
有時候我們常常會叫做s-t path

101
00:04:01,700 --> 00:04:02,700
那它的意思就是

102
00:04:02,700 --> 00:04:03,700
起點是s

103
00:04:03,700 --> 00:04:05,700
終點是t的意思

104
00:04:05,700 --> 00:04:07,700
那從s到t

105
00:04:07,700 --> 00:04:10,700
它中間經過的edge個數是越少越好 

106
00:04:10,700 --> 00:04:12,700
那如果你可以找出來的話

107
00:04:12,700 --> 00:04:14,700
那我們就叫做1 to 1的shortest path

108
00:04:14,700 --> 00:04:16,700
on a unigraph

109
00:04:16,700 --> 00:04:18,700
這樣的意思

110
00:04:18,700 --> 00:04:19,700
好 

111
00:04:19,700 --> 00:04:20,700
它當然有很多的應用

112
00:04:20,700 --> 00:04:22,700
譬如說這邊就舉出一個

113
00:04:22,700 --> 00:04:23,700
譬如說在social network

114
00:04:23,700 --> 00:04:25,700
我到底從我這個點

115
00:04:25,700 --> 00:04:26,700
我這個人

116
00:04:26,700 --> 00:04:27,700
要經由幾個朋友

117
00:04:27,700 --> 00:04:29,700
才可以touch到另外的一個人

118
00:04:29,700 --> 00:04:31,700
那可以去用這個關係

119
00:04:31,700 --> 00:04:34,700
來看看它們的親近關係之類的

120
00:04:34,700 --> 00:04:35,700
好 

121
00:04:35,700 --> 00:04:35,700
不管

122
00:04:35,700 --> 00:04:36,700
然後再來

123
00:04:36,700 --> 00:04:40,700
我們要講的是一個很重要的應用

124
00:04:40,700 --> 00:04:42,700
我們稱之為search algorithm

125
00:04:42,700 --> 00:04:44,700
那search algorithm

126
00:04:44,700 --> 00:04:45,700
當然就是一個algorithm

127
00:04:45,700 --> 00:04:46,700
就是一個演算法

128
00:04:46,700 --> 00:04:47,700
好 

129
00:04:47,700 --> 00:04:49,700
那它這演算法的功能呢

130
00:04:49,700 --> 00:04:50,700
好 

131
00:04:50,700 --> 00:04:52,700
它就是希望我給定了某一個圖

132
00:04:52,700 --> 00:04:54,700
g給定一個起點s

133
00:04:54,700 --> 00:04:57,700
請把s所可以touch到的

134
00:04:57,700 --> 00:04:59,700
所有的點都回報給我

135
00:04:59,700 --> 00:05:02,700
我們稱之為reachable的vertex

136
00:05:02,700 --> 00:05:03,700
所構成的集合

137
00:05:03,700 --> 00:05:04,700
好 

138
00:05:04,700 --> 00:05:06,700
那通通都告訴我

139
00:05:06,700 --> 00:05:07,700
啊

140
00:05:07,700 --> 00:05:07,700
它的意思當然就是

141
00:05:07,700 --> 00:05:08,700
既然是reachable

142
00:05:08,700 --> 00:05:09,700
那意思就是

143
00:05:09,700 --> 00:05:13,700
它跟s可以有一條path去連接嗎

144
00:05:13,700 --> 00:05:14,700
好 

145
00:05:14,700 --> 00:05:15,700
那

146
00:05:15,700 --> 00:05:17,700
這樣子就可以知道

147
00:05:17,700 --> 00:05:18,700
我從這個點出發

148
00:05:18,700 --> 00:05:21,700
我到底可以touch到哪些其它的點

149
00:05:21,700 --> 00:05:22,700
好 

150
00:05:22,700 --> 00:05:23,700
那

151
00:05:23,700 --> 00:05:25,700
這個我們稱之為search的演算法

152
00:05:25,700 --> 00:05:26,700
好 

153
00:05:26,700 --> 00:05:27,700
ok

154
00:05:27,700 --> 00:05:28,700
好 

155
00:05:28,700 --> 00:05:29,700
那等一下我們

156
00:05:29,700 --> 00:05:31,700
就會介紹第一個

157
00:05:31,700 --> 00:05:32,700
這個search演算法

158
00:05:32,700 --> 00:05:33,700
稱之為

159
00:05:33,700 --> 00:05:35,700
BFS

160
00:05:35,700 --> 00:05:36,700
好 

161
00:05:36,700 --> 00:05:36,700
ok

162
00:05:36,700 --> 00:05:37,700
那在講那個之前

163
00:05:37,700 --> 00:05:39,700
我們先定義一些基本的名詞

164
00:05:39,700 --> 00:05:40,700
好 

165
00:05:40,700 --> 00:05:41,700
那首先

166
00:05:41,700 --> 00:05:43,700
在我們在做這個

167
00:05:43,700 --> 00:05:44,700
BFS

168
00:05:44,700 --> 00:05:46,700
它的目的其實就是要去搜尋

169
00:05:46,700 --> 00:05:47,700
好 

170
00:05:47,700 --> 00:05:49,700
那從這個點出發點s

171
00:05:49,700 --> 00:05:51,700
它可以touch到哪些其它點

172
00:05:51,700 --> 00:05:52,700
除此之外

173
00:05:52,700 --> 00:05:53,700
它的那個touch的方式

174
00:05:53,700 --> 00:05:54,700
哦

175
00:05:54,700 --> 00:05:56,700
剛好 也可以讓我們定出

176
00:05:56,700 --> 00:05:59,700
這個起點s到某一個點i

177
00:05:59,700 --> 00:06:00,700
好 

178
00:06:00,700 --> 00:06:02,700
它的最短的走法

179
00:06:02,700 --> 00:06:05,700
還有最短是幾段edge可以touch到

180
00:06:05,700 --> 00:06:08,700
那最短幾段edge可以touch到

181
00:06:08,700 --> 00:06:11,700
那不就是我們剛才所定義的distance嗎

182
00:06:11,700 --> 00:06:12,700
對

183
00:06:12,700 --> 00:06:14,700
所以我們針對一個起點s

184
00:06:14,700 --> 00:06:16,700
然後它如果可以touch到

185
00:06:16,700 --> 00:06:17,700
某一個點i

186
00:06:17,700 --> 00:06:19,700
那請問從s到i

187
00:06:19,700 --> 00:06:22,700
中間最短經過幾段edge

188
00:06:22,700 --> 00:06:23,700
那我們就稱之為

189
00:06:23,700 --> 00:06:25,700
distance label di

190
00:06:25,700 --> 00:06:26,700
這樣子

191
00:06:26,700 --> 00:06:27,700
好 

192
00:06:27,700 --> 00:06:28,700
那你這個touch的方式

193
00:06:28,700 --> 00:06:30,700
其實就會定義一條path

194
00:06:30,700 --> 00:06:32,700
其實就是shortest path

195
00:06:32,700 --> 00:06:35,700
從s一路連到i

196
00:06:35,700 --> 00:06:36,700
好 

197
00:06:36,700 --> 00:06:37,700
那你在i的前面那個點

198
00:06:37,700 --> 00:06:39,700
就叫做predecessor of i

199
00:06:39,700 --> 00:06:42,700
那在predecessor i的前面那個點

200
00:06:42,700 --> 00:06:44,700
那當然就是predecessor

201
00:06:44,700 --> 00:06:47,700
predecessor i

202
00:06:47,700 --> 00:06:49,700
就是寫成這樣

203
00:06:49,700 --> 00:06:51,700
這就是一個遞回的概念

204
00:06:51,700 --> 00:06:53,700
i的predecessor

205
00:06:53,700 --> 00:06:54,700
它的predecessor

206
00:06:54,700 --> 00:06:57,700
那這樣子你就可以往前一直去追蹤出來

207
00:06:57,700 --> 00:06:58,700
好 

208
00:06:58,700 --> 00:07:00,700
那待會在我們的演算法裡面

209
00:07:00,700 --> 00:07:02,700
我們還會定義一些

210
00:07:02,700 --> 00:07:03,700
動詞或名詞

211
00:07:03,700 --> 00:07:05,700
譬如說有一個vertex

212
00:07:05,700 --> 00:07:06,700
我們說

213
00:07:06,700 --> 00:07:08,700
它已經被我marked

214
00:07:08,700 --> 00:07:11,700
那mark意思就是被我做標記了

215
00:07:11,700 --> 00:07:12,700
啊

216
00:07:12,700 --> 00:07:14,700
做標記就是被我拜訪過的意思

217
00:07:14,700 --> 00:07:15,700
好 

218
00:07:15,700 --> 00:07:17,700
那不然就是它還沒有被我拜訪過

219
00:07:17,700 --> 00:07:19,700
還沒拜訪過就是unmarked

220
00:07:19,700 --> 00:07:22,700
或者是unvisited就一樣的意思

221
00:07:22,700 --> 00:07:23,700
好 

222
00:07:23,700 --> 00:07:25,700
那所以等一下我們的

223
00:07:25,700 --> 00:07:27,700
演算法的操作過程當中

224
00:07:27,700 --> 00:07:28,700
如果有某一個點

225
00:07:28,700 --> 00:07:30,700
它被我mark的話

226
00:07:30,700 --> 00:07:33,700
那當然就是它有被我touch到

227
00:07:33,700 --> 00:07:34,700
被我touch到

228
00:07:34,700 --> 00:07:35,700
那一定就是reachable

229
00:07:35,700 --> 00:07:37,700
from這個點s

230
00:07:37,700 --> 00:07:38,700
好 

231
00:07:38,700 --> 00:07:41,700
那再來我們還會定義一個名詞

232
00:07:41,700 --> 00:07:43,700
叫做admissible

233
00:07:43,700 --> 00:07:45,700
admissible

234
00:07:45,700 --> 00:07:46,700
admissible就叫做

235
00:07:46,700 --> 00:07:48,700
這中文有時候不是很好 翻

236
00:07:48,700 --> 00:07:50,700
應該是

237
00:07:50,700 --> 00:07:51,700
可以用

238
00:07:51,700 --> 00:07:53,700
應該是可以這樣

239
00:07:53,700 --> 00:07:55,700
這樣可以這樣理解

240
00:07:55,700 --> 00:07:57,700
我們說某一個edge

241
00:07:57,700 --> 00:08:00,700
這個edge就在一個edge set

242
00:08:00,700 --> 00:08:02,700
就是我們結線會有一個set

243
00:08:02,700 --> 00:08:04,700
然後我們其中抽了一條

244
00:08:04,700 --> 00:08:05,700
叫做edge ij

245
00:08:05,700 --> 00:08:07,700
好 

246
00:08:07,700 --> 00:08:08,700
然後我們說

247
00:08:08,700 --> 00:08:09,700
這條是我們現在可以用

248
00:08:09,700 --> 00:08:10,700
什麼叫做我們可以用

249
00:08:10,700 --> 00:08:12,700
就是當這一條

250
00:08:12,700 --> 00:08:15,700
叫做i連到j的這一條

251
00:08:15,700 --> 00:08:17,700
這是一條edge而已

252
00:08:17,700 --> 00:08:19,700
然後這一條我們稱之為

253
00:08:19,700 --> 00:08:20,700
它現在是admissible

254
00:08:20,700 --> 00:08:21,700
為什麼

255
00:08:21,700 --> 00:08:24,700
因為如果現在你i

256
00:08:24,700 --> 00:08:26,700
已經被你mark了

257
00:08:26,700 --> 00:08:27,700
意思就是

258
00:08:27,700 --> 00:08:28,700
根據我們剛才的說法

259
00:08:28,700 --> 00:08:30,700
我已經拜訪過它了

260
00:08:30,700 --> 00:08:32,700
可是j還沒有到來拜訪

261
00:08:32,700 --> 00:08:34,700
所以等同於我現在已經touch到i

262
00:08:34,700 --> 00:08:35,700
我還沒touch到j

263
00:08:35,700 --> 00:08:38,700
可是我其實是可以touch到j的

264
00:08:38,700 --> 00:08:39,700
為什麼

265
00:08:39,700 --> 00:08:41,700
因為ij這條edge是存在的

266
00:08:41,700 --> 00:08:43,700
我可以藉由ij這條edge

267
00:08:43,700 --> 00:08:45,700
從i去touch到j

268
00:08:45,700 --> 00:08:47,700
只不過我還沒有touch

269
00:08:47,700 --> 00:08:48,700
好 

270
00:08:48,700 --> 00:08:50,700
那當這種情況出現的時候

271
00:08:50,700 --> 00:08:52,700
也就是一頭已經被mark

272
00:08:52,700 --> 00:08:54,700
一頭還沒有被mark

273
00:08:54,700 --> 00:08:56,700
然後這條edge的確存在

274
00:08:56,700 --> 00:08:57,700
如果是這樣的話

275
00:08:57,700 --> 00:08:58,700
我們就稱這一條edge

276
00:08:58,700 --> 00:09:00,700
叫做admissible

277
00:09:00,700 --> 00:09:01,700
大家不用太

278
00:09:01,700 --> 00:09:03,700
太執著於這個名詞

279
00:09:03,700 --> 00:09:04,700
像說我是不是要把它背起來

280
00:09:04,700 --> 00:09:05,700
不用

281
00:09:05,700 --> 00:09:06,700
你就把它

282
00:09:06,700 --> 00:09:07,700
之所以要定義這個是

283
00:09:07,700 --> 00:09:09,700
因為等一下我們要去

284
00:09:09,700 --> 00:09:12,700
從一個點一直往外去散發

285
00:09:12,700 --> 00:09:13,700
連出去

286
00:09:13,700 --> 00:09:14,700
然後我們要連出去

287
00:09:14,700 --> 00:09:15,700
我們一定要找

288
00:09:15,700 --> 00:09:17,700
我們覺得可以連的

289
00:09:17,700 --> 00:09:18,700
我們才連出去

290
00:09:18,700 --> 00:09:19,700
所以這邊admissible

291
00:09:19,700 --> 00:09:20,700
其實就是在講

292
00:09:20,700 --> 00:09:22,700
所謂的我們可以連的

293
00:09:22,700 --> 00:09:23,700
這樣子

294
00:09:23,700 --> 00:09:24,700
好 

295
00:09:24,700 --> 00:09:26,700
什麼叫做我們不用連

296
00:09:26,700 --> 00:09:27,700
我們不用連

297
00:09:27,700 --> 00:09:28,700
就是如果當我們兩邊

298
00:09:28,700 --> 00:09:29,700
舉例來講

299
00:09:29,700 --> 00:09:30,700
我們現在的目的

300
00:09:30,700 --> 00:09:31,700
如果是要把

301
00:09:31,700 --> 00:09:32,700
所有可以touch到的

302
00:09:32,700 --> 00:09:33,700
都touch的話

303
00:09:33,700 --> 00:09:34,700
好 

304
00:09:34,700 --> 00:09:35,700
那你現在如果站在一個點

305
00:09:35,700 --> 00:09:36,700
譬如說我現在在i

306
00:09:36,700 --> 00:09:38,700
然後如果對方這一頭

307
00:09:38,700 --> 00:09:39,700
也已經被我touch過了

308
00:09:39,700 --> 00:09:41,700
那你就沒有必要

309
00:09:41,700 --> 00:09:42,700
再走過這一條

310
00:09:42,700 --> 00:09:43,700
i這一條

311
00:09:43,700 --> 00:09:44,700
好 

312
00:09:44,700 --> 00:09:45,700
因為對方已經被你touch到了

313
00:09:45,700 --> 00:09:47,700
因為我們現在的目的

314
00:09:47,700 --> 00:09:48,700
就是想辦法去touch到

315
00:09:48,700 --> 00:09:49,700
我們可以touch到的

316
00:09:49,700 --> 00:09:51,700
啊既然它對方已經被我touch到

317
00:09:51,700 --> 00:09:53,700
我就不用再做這些事情了

318
00:09:53,700 --> 00:09:54,700
因為它已經被我touch到

319
00:09:54,700 --> 00:09:55,700
好 

320
00:09:55,700 --> 00:09:56,700
就可以這樣來理解

321
00:09:56,700 --> 00:09:57,700
所以這個admissible

322
00:09:57,700 --> 00:09:58,700
其實沒有什麼大不了

323
00:09:58,700 --> 00:09:59,700
你就是把它當成說

324
00:09:59,700 --> 00:10:02,700
我的演算法的某一個過程

325
00:10:02,700 --> 00:10:04,700
在當下我到底

326
00:10:04,700 --> 00:10:06,700
啊可不可以

327
00:10:06,700 --> 00:10:08,700
需不需要經由這一條edge

328
00:10:08,700 --> 00:10:11,700
可以可以用還是不需要用

329
00:10:11,700 --> 00:10:13,700
啊如果是可以過的話

330
00:10:13,700 --> 00:10:14,700
好 

331
00:10:14,700 --> 00:10:15,700
 我們就稱之為admissible

332
00:10:15,700 --> 00:10:16,700
就這樣而已

333
00:10:16,700 --> 00:10:18,700
好 

334
00:10:18,700 --> 00:10:19,700
然後再來我們就要講

335
00:10:19,700 --> 00:10:21,700
我們的BFS的演算法

336
00:10:21,700 --> 00:10:25,700
BFS是來自於Breadth first search

337
00:10:25,700 --> 00:10:27,700
這三個字的簡寫

338
00:10:27,700 --> 00:10:30,700
那Breadth就是寬度廣度

339
00:10:30,700 --> 00:10:32,700
那first就優先

340
00:10:32,700 --> 00:10:35,700
所以大家如果 看一些綜藝版啊

341
00:10:35,700 --> 00:10:38,700
都會叫做廣度優先搜尋法

342
00:10:38,700 --> 00:10:40,700
那從這個名字來看

343
00:10:40,700 --> 00:10:41,700
也就是越廣越好 

344
00:10:41,700 --> 00:10:42,700
越廣越好 

345
00:10:42,700 --> 00:10:43,700
好 

346
00:10:43,700 --> 00:10:45,700
啊或者你把它想像成

347
00:10:45,700 --> 00:10:46,700
我站在一個點i

348
00:10:46,700 --> 00:10:48,700
假設我有5條可以連出去

349
00:10:48,700 --> 00:10:49,700
好 

350
00:10:49,700 --> 00:10:50,700
那我就是把我可以連出去的

351
00:10:50,700 --> 00:10:52,700
我都去給它碰碰碰碰碰

352
00:10:52,700 --> 00:10:54,700
都都把它touch到

353
00:10:54,700 --> 00:10:56,700
全部可以touch我都touch了

354
00:10:56,700 --> 00:10:57,700
這是越廣越好 

355
00:10:57,700 --> 00:10:58,700
好 

356
00:10:58,700 --> 00:10:59,700
大概是這樣的概念

357
00:10:59,700 --> 00:11:00,700
好 

358
00:11:00,700 --> 00:11:01,700
那這其實是要去對比於之後

359
00:11:01,700 --> 00:11:03,700
我們會有另外一個演算法

360
00:11:03,700 --> 00:11:05,700
叫做dfs

361
00:11:05,700 --> 00:11:07,700
那這個後面的f跟s

362
00:11:07,700 --> 00:11:08,700
就跟這裡是一樣的

363
00:11:08,700 --> 00:11:09,700
只不過這裡的d

364
00:11:09,700 --> 00:11:10,700
好 

365
00:11:10,700 --> 00:11:12,700
其實是深度depth first search

366
00:11:12,700 --> 00:11:13,700
好 

367
00:11:13,700 --> 00:11:15,700
那深度也優先演算法

368
00:11:15,700 --> 00:11:17,700
它的概念就跟廣度優先

369
00:11:17,700 --> 00:11:19,700
以它的意義

370
00:11:19,700 --> 00:11:21,700
字面上就可以看出差別

371
00:11:21,700 --> 00:11:22,700
因為深度優先

372
00:11:22,700 --> 00:11:24,700
你可以把它想成好 像潛水一樣

373
00:11:24,700 --> 00:11:25,700
就是我一旦touch到一個

374
00:11:25,700 --> 00:11:28,700
我就從這邊站在浪頭上

375
00:11:28,700 --> 00:11:30,700
我繼續往下去鑽

376
00:11:30,700 --> 00:11:31,700
一直往下鑽

377
00:11:31,700 --> 00:11:32,700
那廣度優先的話

378
00:11:32,700 --> 00:11:34,700
它是我只要還可以鑽

379
00:11:34,700 --> 00:11:35,700
 

380
00:11:35,700 --> 00:11:36,700
我只要在這邊還沒touch到

381
00:11:36,700 --> 00:11:37,700
我就通通給它touch

382
00:11:37,700 --> 00:11:38,700
好 

383
00:11:38,700 --> 00:11:39,700
越廣越好 

384
00:11:39,700 --> 00:11:40,700
一個是一直鑽的越深越好 

385
00:11:40,700 --> 00:11:42,700
大概是這樣的差別

386
00:11:42,700 --> 00:11:43,700
好 

387
00:11:43,700 --> 00:11:45,700
然後在我們現在就要講我們的演算法

388
00:11:45,700 --> 00:11:47,700
那要去理解演算法

389
00:11:47,700 --> 00:11:49,700
最容易的方式應該就是直接

390
00:11:49,700 --> 00:11:50,700
 

391
00:11:50,700 --> 00:11:52,700
看我們的動畫

392
00:11:52,700 --> 00:11:53,700
好 

393
00:11:53,700 --> 00:11:54,700
所以以下我們就用一個動畫來解釋

394
00:11:54,700 --> 00:11:55,700
好 

395
00:11:55,700 --> 00:11:57,700
那這個動畫 我們先

396
00:11:57,700 --> 00:12:00,700
假設我們的圖是有像圖

397
00:12:00,700 --> 00:12:02,700
其實無像圖有像圖都可以啊

398
00:12:02,700 --> 00:12:03,700
好 

399
00:12:03,700 --> 00:12:06,700
那用有像圖好 像比較general

400
00:12:06,700 --> 00:12:07,700
比較容易解釋

401
00:12:07,700 --> 00:12:08,700
好 

402
00:12:08,700 --> 00:12:09,700
啊為什麼說比較general

403
00:12:09,700 --> 00:12:11,700
因為因為如果是無像圖

404
00:12:11,700 --> 00:12:12,700
你可以把它理解為雙向

405
00:12:12,700 --> 00:12:14,700
也就是從i到j

406
00:12:14,700 --> 00:12:15,700
這也可以到i

407
00:12:15,700 --> 00:12:16,700
好 

408
00:12:16,700 --> 00:12:17,700
那有像圖的話

409
00:12:17,700 --> 00:12:19,700
它就不是雙向

410
00:12:19,700 --> 00:12:21,700
哎它它可以是雙向

411
00:12:21,700 --> 00:12:23,700
可是很常它不會是雙向

412
00:12:23,700 --> 00:12:24,700
以這個圖為例

413
00:12:24,700 --> 00:12:26,700
我們看1這個點

414
00:12:26,700 --> 00:12:27,700
好 

415
00:12:27,700 --> 00:12:28,700
它就只有出沒有進

416
00:12:28,700 --> 00:12:29,700
以8這個點

417
00:12:29,700 --> 00:12:30,700
它就只有進沒有出

418
00:12:30,700 --> 00:12:32,700
啊這個如果是在

419
00:12:32,700 --> 00:12:33,700
啊

420
00:12:33,700 --> 00:12:35,700
undirected graph的話

421
00:12:35,700 --> 00:12:36,700
哦就不會這樣

422
00:12:36,700 --> 00:12:37,700
因為undirected graph

423
00:12:37,700 --> 00:12:39,700
它是可以進可出

424
00:12:39,700 --> 00:12:41,700
啊因為它就同一條嗎

425
00:12:41,700 --> 00:12:42,700
好 

426
00:12:42,700 --> 00:12:43,700
我們現在

427
00:12:43,700 --> 00:12:45,700
 就直接以這個圖

428
00:12:45,700 --> 00:12:48,700
我先用一個概念的方式來講

429
00:12:48,700 --> 00:12:49,700
好 

430
00:12:49,700 --> 00:12:52,700
因為要去解釋BFS有幾種解釋的方式

431
00:12:52,700 --> 00:12:54,700
我先用圖形的方式來講

432
00:12:54,700 --> 00:12:57,700
那圖形方式反而是比較直覺

433
00:12:57,700 --> 00:12:58,700
我覺得那圖形方式

434
00:12:58,700 --> 00:13:00,700
如果你大概可以理解

435
00:13:00,700 --> 00:13:01,700
好 

436
00:13:01,700 --> 00:13:03,700
那我們再用資料結構的方式來講

437
00:13:03,700 --> 00:13:04,700
大概是這樣

438
00:13:04,700 --> 00:13:05,700
好 

439
00:13:05,700 --> 00:13:06,700
那資料結構方式呢

440
00:13:06,700 --> 00:13:08,700
其實會用到q的概念

441
00:13:08,700 --> 00:13:12,700
q就是fefo就是first in first out的概念

442
00:13:12,700 --> 00:13:13,700
好 

443
00:13:13,700 --> 00:13:13,700
不過我們先不用那個

444
00:13:13,700 --> 00:13:17,700
我們就先用概念直覺來講

445
00:13:17,700 --> 00:13:18,700
好 

446
00:13:18,700 --> 00:13:19,700
所以等一下我的demo的過程

447
00:13:19,700 --> 00:13:21,700
也會有出現q

448
00:13:21,700 --> 00:13:23,700
大家可以先無視它

449
00:13:23,700 --> 00:13:26,700
我們先用直覺的方式來理解就好 

450
00:13:26,700 --> 00:13:27,700
好 

451
00:13:27,700 --> 00:13:28,700
那一開始

452
00:13:28,700 --> 00:13:29,700
好 

453
00:13:29,700 --> 00:13:30,700
我們我我用口語的方式

454
00:13:30,700 --> 00:13:32,700
所以我不見得完全會follow

455
00:13:32,700 --> 00:13:34,700
我這邊所寫的這些

456
00:13:34,700 --> 00:13:35,700
 注釋

457
00:13:35,700 --> 00:13:36,700
好 

458
00:13:36,700 --> 00:13:36,700
好 

459
00:13:36,700 --> 00:13:39,700
首先假設我們從我們我們現在從1出發好 了

460
00:13:39,700 --> 00:13:42,700
那我們現在BFS如果從1出發

461
00:13:42,700 --> 00:13:45,700
我們的重點就是希望把這個圖上可以touch到的

462
00:13:45,700 --> 00:13:47,700
我通通都touch

463
00:13:47,700 --> 00:13:49,700
啊我而我touch的方式呢

464
00:13:49,700 --> 00:13:50,700
是站在一個點

465
00:13:50,700 --> 00:13:52,700
我只要還可以連通

466
00:13:52,700 --> 00:13:53,700
 

467
00:13:53,700 --> 00:13:55,700
我這個點可以連出去的

468
00:13:55,700 --> 00:13:56,700
我就通通都連完

469
00:13:56,700 --> 00:13:58,700
我才去考慮下一個點

470
00:13:58,700 --> 00:13:59,700
好 

471
00:13:59,700 --> 00:13:59,700
大概是這樣概念

472
00:13:59,700 --> 00:14:00,700
好 

473
00:14:00,700 --> 00:14:01,700
然後還有另外一個概念就是

474
00:14:01,700 --> 00:14:05,700
等一下我要選誰來當我的

475
00:14:05,700 --> 00:14:06,700
 

476
00:14:06,700 --> 00:14:07,700
起點

477
00:14:07,700 --> 00:14:07,700
好 

478
00:14:07,700 --> 00:14:08,700
有時候起點跟原點

479
00:14:08,700 --> 00:14:09,700
我會有點搞混

480
00:14:09,700 --> 00:14:10,700
到底哪個是哪個

481
00:14:10,700 --> 00:14:11,700
好 

482
00:14:11,700 --> 00:14:12,700
我們如果先定義好 

483
00:14:12,700 --> 00:14:14,700
就是原點就是1好 了

484
00:14:14,700 --> 00:14:15,700
這叫做原點

485
00:14:15,700 --> 00:14:16,700
好 

486
00:14:16,700 --> 00:14:16,700
然後起點呢

487
00:14:16,700 --> 00:14:19,700
就是等一下我們會站在某一個點

488
00:14:19,700 --> 00:14:21,700
用當它當作起點

489
00:14:21,700 --> 00:14:24,700
然後從它去touch它的隔壁那個叫做起點

490
00:14:24,700 --> 00:14:25,700
好 

491
00:14:25,700 --> 00:14:28,700
所以我們現在就是先把它想成說

492
00:14:28,700 --> 00:14:30,700
哎1就是我們的原點

493
00:14:30,700 --> 00:14:32,700
也是我們的起點

494
00:14:32,700 --> 00:14:34,700
那根據我剛才所講的

495
00:14:34,700 --> 00:14:35,700
好 

496
00:14:35,700 --> 00:14:36,700
就我們要站在1

497
00:14:36,700 --> 00:14:38,700
然後可以touch就就去touch

498
00:14:38,700 --> 00:14:40,700
至於它的順序其實是隨便你

499
00:14:40,700 --> 00:14:41,700
好 

500
00:14:41,700 --> 00:14:42,700
那所以舉例來講

501
00:14:42,700 --> 00:14:43,700
我現在如果先touch12

502
00:14:43,700 --> 00:14:44,700
好 

503
00:14:44,700 --> 00:14:47,700
我們先先無視下面我所寫的這些啊資料結構

504
00:14:47,700 --> 00:14:49,700
好 

505
00:14:49,700 --> 00:14:50,700
我們先看上面的這個圖就好 

506
00:14:50,700 --> 00:14:51,700
我先touch12

507
00:14:51,700 --> 00:14:52,700
好 

508
00:14:52,700 --> 00:14:54,700
然後這樣2就被我touch到對不對

509
00:14:54,700 --> 00:14:55,700
好 

510
00:14:55,700 --> 00:14:57,700
就把它想成說哎它它touch到變成紅色

511
00:14:57,700 --> 00:14:58,700
好 

512
00:14:58,700 --> 00:14:58,700
然後再來呢

513
00:14:58,700 --> 00:14:59,700
再來我們就touch15

514
00:14:59,700 --> 00:15:00,700
好 

515
00:15:00,700 --> 00:15:01,700
我可以touch的我就去touch

516
00:15:01,700 --> 00:15:04,700
所以我是不是就依序可以把1跟5

517
00:15:04,700 --> 00:15:07,700
121513都touch到

518
00:15:07,700 --> 00:15:08,700
那剛才老師講過

519
00:15:08,700 --> 00:15:11,700
你是要121513先touch誰

520
00:15:11,700 --> 00:15:12,700
其實隨便你

521
00:15:12,700 --> 00:15:13,700
因為都可以

522
00:15:13,700 --> 00:15:14,700
好 

523
00:15:14,700 --> 00:15:15,700
因為反正遲早不是遲早

524
00:15:15,700 --> 00:15:17,700
這總之你站在1

525
00:15:17,700 --> 00:15:19,700
可以touch你都要先touch完嗎

526
00:15:19,700 --> 00:15:23,700
所以不管你是先touch2還是5還是3還是352

527
00:15:23,700 --> 00:15:25,700
whatever順序根本都沒差

528
00:15:25,700 --> 00:15:28,700
反正你一定253通通都要touch完

529
00:15:28,700 --> 00:15:30,700
你才能夠再做下一步

530
00:15:30,700 --> 00:15:33,700
那我們現在其實就是253都touch完了

531
00:15:33,700 --> 00:15:35,700
我們要準備做下一步

532
00:15:35,700 --> 00:15:36,700
好 

533
00:15:36,700 --> 00:15:38,700
哎下一步應該要怎麼去做

534
00:15:38,700 --> 00:15:42,700
就是我們要選一個新的起點

535
00:15:42,700 --> 00:15:43,700
好 

536
00:15:42,700 --> 00:15:45,700
我們再重新定義我們的名詞

537
00:15:45,700 --> 00:15:49,700
我們假設起點就是你現在要站的那個點叫做起點

538
00:15:49,700 --> 00:15:52,700
那我們本來的起點就是原點自己也就是1

539
00:15:52,700 --> 00:15:53,700
好 

540
00:15:53,700 --> 00:15:56,700
我正在1已經去touch到我可以touch了

541
00:15:56,700 --> 00:15:58,700
可是它已經空工程生退了

542
00:15:58,700 --> 00:16:00,700
因為它可以touch都touch完了嗎

543
00:16:00,700 --> 00:16:03,700
所以再來我們要選新的起點

544
00:16:03,700 --> 00:16:05,700
然後新的起點是253

545
00:16:05,700 --> 00:16:07,700
理論上都可以

546
00:16:07,700 --> 00:16:09,700
那為了有一個一致的規則

547
00:16:09,700 --> 00:16:12,700
我們現在就再定一個規則

548
00:16:12,700 --> 00:16:15,700
就是我們選起點的方式呢

549
00:16:15,700 --> 00:16:19,700
是1誰當初比較先被我touch到的

550
00:16:19,700 --> 00:16:21,700
它比較有優先權

551
00:16:21,700 --> 00:16:24,700
其實就是first in first out的概念

552
00:16:24,700 --> 00:16:25,700
好 

553
00:16:25,700 --> 00:16:26,700
那如果以我們剛才的順序

554
00:16:26,700 --> 00:16:30,700
我們假設是從2先touch再5再3的話

555
00:16:30,700 --> 00:16:33,700
那就是我們先把2拿來當我的起點的意思

556
00:16:33,700 --> 00:16:34,700
好 

557
00:16:34,700 --> 00:16:36,700
所以我們現在就站在2當起點

558
00:16:36,700 --> 00:16:38,700
那2當起點

559
00:16:38,700 --> 00:16:40,700
然後就重複剛才1的那件事情

560
00:16:40,700 --> 00:16:43,700
也就是我站在2看它可以touch到誰

561
00:16:43,700 --> 00:16:47,700
那我們現在一看它可以touch到4跟5

562
00:16:47,700 --> 00:16:49,700
那先touch誰

563
00:16:49,700 --> 00:16:51,700
假設我們就1

564
00:16:51,700 --> 00:16:52,700
我們的高限

565
00:16:52,700 --> 00:16:54,700
譬如說從上面到下面這個順序好 了

566
00:16:54,700 --> 00:16:55,700
好 

567
00:16:55,700 --> 00:16:57,700
那譬如說我先touch到4

568
00:16:57,700 --> 00:16:59,700
那這樣4是不是就變成紅色了

569
00:16:59,700 --> 00:17:00,700
好 

570
00:17:00,700 --> 00:17:02,700
然後再來我們是不是要touch5

571
00:17:02,700 --> 00:17:04,700
需要去touch5嗎

572
00:17:04,700 --> 00:17:05,700
不用

573
00:17:05,700 --> 00:17:06,700
因為為什麼

574
00:17:06,700 --> 00:17:07,700
因為5已經是紅色了

575
00:17:07,700 --> 00:17:11,700
因為5剛才已經是被1所touch到了

576
00:17:11,700 --> 00:17:13,700
所以你檢查了一下發現說

577
00:17:13,700 --> 00:17:15,700
我5不用去touch它

578
00:17:15,700 --> 00:17:17,700
大概是這個意思

579
00:17:17,700 --> 00:17:18,700
好 

580
00:17:18,700 --> 00:17:20,700
然後所以2已經攻城勝退了

581
00:17:20,700 --> 00:17:22,700
因為它可以touch到的就是4跟5

582
00:17:22,700 --> 00:17:24,700
其中5它不用去touch

583
00:17:24,700 --> 00:17:26,700
所以它新touch到的就是4

584
00:17:26,700 --> 00:17:28,700
然後它可以touch都touch完了

585
00:17:28,700 --> 00:17:30,700
所以它也攻城勝退

586
00:17:30,700 --> 00:17:33,700
所以再來我們應該選的起點

587
00:17:33,700 --> 00:17:35,700
因為我們剛才1已經選了

588
00:17:35,700 --> 00:17:36,700
2也選了

589
00:17:36,700 --> 00:17:37,700
好 

590
00:17:37,700 --> 00:17:39,700
再來就是5是下一個

591
00:17:39,700 --> 00:17:40,700
為什麼

592
00:17:40,700 --> 00:17:42,700
因為我們剛才有規定說

593
00:17:42,700 --> 00:17:45,700
誰先當被我touch到的

594
00:17:45,700 --> 00:17:46,700
它就有優先權

595
00:17:46,700 --> 00:17:48,700
所以我們現在就是5是相對

596
00:17:48,700 --> 00:17:50,700
現在是排頭老大

597
00:17:50,700 --> 00:17:51,700
好 

598
00:17:51,700 --> 00:17:52,700
那我們就站在5

599
00:17:52,700 --> 00:17:53,700
看說5可以去touch誰

600
00:17:53,700 --> 00:17:56,700
那我們如果follow它的方向性的話

601
00:17:56,700 --> 00:17:58,700
我們就發現5只能夠touch到6

602
00:17:58,700 --> 00:17:59,700
好 

603
00:17:59,700 --> 00:18:00,700
所以你就touch到6

604
00:18:00,700 --> 00:18:01,700
好 

605
00:18:01,700 --> 00:18:02,700
那5就攻城勝退了

606
00:18:02,700 --> 00:18:04,700
因為5可以出去就只有到6而已

607
00:18:04,700 --> 00:18:05,700
好 

608
00:18:05,700 --> 00:18:06,700
所以5就也結束了

609
00:18:06,700 --> 00:18:08,700
再來再看誰要當新的起點

610
00:18:08,700 --> 00:18:10,700
根據剛才的順序

611
00:18:10,700 --> 00:18:11,700
就是3來當新的起點

612
00:18:11,700 --> 00:18:12,700
好 

613
00:18:12,700 --> 00:18:14,700
那3可以touch到5跟6

614
00:18:14,700 --> 00:18:15,700
可是對方都已經紅了

615
00:18:15,700 --> 00:18:18,700
所以它就攻城勝退

616
00:18:18,700 --> 00:18:19,700
好 

617
00:18:19,700 --> 00:18:21,700
所以我們剛才的歷程當中

618
00:18:21,700 --> 00:18:25,700
其實就是把它看成就一層一層的概念

619
00:18:25,700 --> 00:18:26,700
也就是我第0層

620
00:18:26,700 --> 00:18:28,700
看你要說第0還是第1

621
00:18:28,700 --> 00:18:30,700
就是我的原點

622
00:18:30,700 --> 00:18:31,700
先整個完

623
00:18:31,700 --> 00:18:32,700
然後再來我第一層

624
00:18:32,700 --> 00:18:34,700
touch到了2、5、3、1

625
00:18:34,700 --> 00:18:35,700
這樣的順序

626
00:18:35,700 --> 00:18:36,700
好 

627
00:18:36,700 --> 00:18:38,700
那我就1、2、5、3的順序來選

628
00:18:38,700 --> 00:18:40,700
來當我的起點

629
00:18:40,700 --> 00:18:43,700
然後等到它第一層都當過起點之後

630
00:18:43,700 --> 00:18:46,700
再來我們就要選第二層來當起點

631
00:18:46,700 --> 00:18:48,700
在我們這邊的第二層就是4跟6

632
00:18:48,700 --> 00:18:49,700
這兩個點

633
00:18:49,700 --> 00:18:50,700
請問4跟6這兩個點

634
00:18:50,700 --> 00:18:52,700
哪一個先被我touch到

635
00:18:52,700 --> 00:18:53,700
根據剛才的操作

636
00:18:53,700 --> 00:18:54,700
4比較先

637
00:18:54,700 --> 00:18:58,700
所以我們就先取4來當我們的起點

638
00:18:58,700 --> 00:18:59,700
好 

639
00:18:59,700 --> 00:19:02,700
所以就一層一層往外的概念

640
00:19:02,700 --> 00:19:04,700
比較淺的層都touch完了

641
00:19:04,700 --> 00:19:06,700
我們才會去touch深的那一層

642
00:19:06,700 --> 00:19:09,700
而誰當起點就是依我們的順序

643
00:19:09,700 --> 00:19:11,700
所以我們現在這4當起點

644
00:19:11,700 --> 00:19:12,700
那4可以touch到誰

645
00:19:12,700 --> 00:19:14,700
可以到5跟8

646
00:19:14,700 --> 00:19:16,700
可是5已經被touch過了

647
00:19:16,700 --> 00:19:17,700
所以我它就touch8

648
00:19:17,700 --> 00:19:18,700
好 

649
00:19:18,700 --> 00:19:19,700
然後4可以touch

650
00:19:19,700 --> 00:19:20,700
touch完了攻城勝退

651
00:19:20,700 --> 00:19:22,700
所以我們現在4完了之後

652
00:19:22,700 --> 00:19:24,700
我們現在用6來當起點

653
00:19:24,700 --> 00:19:25,700
那6當起點

654
00:19:25,700 --> 00:19:26,700
它可以touch到7跟9

655
00:19:26,700 --> 00:19:28,700
那就分別去給它touch

656
00:19:28,700 --> 00:19:30,700
那touch完了之後

657
00:19:30,700 --> 00:19:32,700
6也攻城勝退

658
00:19:32,700 --> 00:19:33,700
所以這個時候

659
00:19:33,700 --> 00:19:35,700
我們剛才1這一層

660
00:19:35,700 --> 00:19:37,700
2是5 3這一層

661
00:19:37,700 --> 00:19:39,700
4 6這一層都完了

662
00:19:39,700 --> 00:19:42,700
再來我們要第三層了

663
00:19:42,700 --> 00:19:43,700
假設這個是第0層

664
00:19:43,700 --> 00:19:44,700
這是第一層

665
00:19:44,700 --> 00:19:45,700
這是第二層

666
00:19:45,700 --> 00:19:46,700
第三層

667
00:19:46,700 --> 00:19:48,700
第三層就是8 7 9

668
00:19:48,700 --> 00:19:51,700
8 7 9這三個

669
00:19:51,700 --> 00:19:53,700
這就是我們的第三層

670
00:19:53,700 --> 00:19:54,700
ok

671
00:19:54,700 --> 00:19:58,700
那請問我要誰先選誰來當起點

672
00:19:58,700 --> 00:20:00,700
根據剛才的做法

673
00:20:00,700 --> 00:20:02,700
我們就選8當起點

674
00:20:02,700 --> 00:20:03,700
那選8當起點

675
00:20:03,700 --> 00:20:05,700
請問它可以touch到誰

676
00:20:05,700 --> 00:20:07,700
8就是指進不出

677
00:20:07,700 --> 00:20:08,700
所以它誰都不能touch

678
00:20:08,700 --> 00:20:09,700
所以你選了8當起點

679
00:20:09,700 --> 00:20:11,700
馬上8就要攻城勝退

680
00:20:11,700 --> 00:20:13,700
再來就選7當起點

681
00:20:13,700 --> 00:20:15,700
7也touch不到誰

682
00:20:15,700 --> 00:20:16,700
也攻城勝退

683
00:20:16,700 --> 00:20:18,700
再來再選9當起點

684
00:20:18,700 --> 00:20:20,700
9也攻城勝退

685
00:20:20,700 --> 00:20:21,700
然後呢

686
00:20:21,700 --> 00:20:23,700
然後請問還有誰可以選

687
00:20:23,700 --> 00:20:24,700
沒有了

688
00:20:24,700 --> 00:20:25,700
沒有了

689
00:20:25,700 --> 00:20:27,700
也就是通通都做完了

690
00:20:27,700 --> 00:20:28,700
ok

691
00:20:28,700 --> 00:20:30,700
其實我們剛才做到6

692
00:20:30,700 --> 00:20:32,700
就大概可以先提前做完

693
00:20:32,700 --> 00:20:35,700
不過這也只省了最後一步而已

694
00:20:35,700 --> 00:20:38,700
我所謂提前做完的意思是

695
00:20:38,700 --> 00:20:39,700
我們的目的

696
00:20:39,700 --> 00:20:41,700
如果是要touch到所有的點的話

697
00:20:41,700 --> 00:20:43,700
我在6的時候

698
00:20:43,700 --> 00:20:45,700
其實所有的點都已經被我touch了

699
00:20:45,700 --> 00:20:47,700
所以其實你也可以不用再做了

700
00:20:47,700 --> 00:20:48,700
因為再做也是枉然

701
00:20:48,700 --> 00:20:51,700
不過站在電腦的角度

702
00:20:51,700 --> 00:20:55,700
就是你要有一個rule去讓它去做

703
00:20:55,700 --> 00:20:59,700
然後你要告訴它什麼時候我要結束

704
00:20:59,700 --> 00:21:02,700
那我剛才講的一個判斷結束的方式是

705
00:21:02,700 --> 00:21:05,700
如果我發現所有的點都被我touch過

706
00:21:05,700 --> 00:21:06,700
我就可以結束了

707
00:21:06,700 --> 00:21:09,700
這也是一種判斷結束的方式

708
00:21:09,700 --> 00:21:11,700
另外一種判斷結束的方式

709
00:21:11,700 --> 00:21:12,700
如果以我這邊演算法

710
00:21:12,700 --> 00:21:14,700
比較簡單的做法

711
00:21:14,700 --> 00:21:17,700
就是當我都沒有人可以拿來當起點

712
00:21:17,700 --> 00:21:19,700
這個時候我就可以結束

713
00:21:19,700 --> 00:21:22,700
所以我們剛才等同於最後一回合

714
00:21:22,700 --> 00:21:26,700
就是8 7 9一路選來當起點

715
00:21:26,700 --> 00:21:28,700
一路又被我刪掉

716
00:21:28,700 --> 00:21:31,700
那等到9的時候就全部都沒了

717
00:21:31,700 --> 00:21:33,700
全部都沒了

718
00:21:33,700 --> 00:21:35,700
你就沒有辦法當選一個點當起點

719
00:21:35,700 --> 00:21:38,700
你就不能夠重複剛才的子步驟

720
00:21:38,700 --> 00:21:39,700
所以你就做完了

721
00:21:39,700 --> 00:21:45,700
好 以上就是BFS的圖形解釋方式

722
00:21:45,700 --> 00:21:47,700
這樣子ok好 

723
00:21:50,700 --> 00:21:53,700
好 看完了圖形解釋方式

724
00:21:53,700 --> 00:21:55,700
再來我們就要再理解

725
00:21:55,700 --> 00:21:57,700
data structure的方式

726
00:21:57,700 --> 00:22:00,700
ok那其實一體的兩面根本是同一件事

727
00:22:00,700 --> 00:22:04,700
好 那 剛才的做法

728
00:22:04,700 --> 00:22:07,700
我們現在寫成shortcut就長成這個樣子

729
00:22:07,700 --> 00:22:10,700
好 那 首先我們先看一開始

730
00:22:10,700 --> 00:22:12,700
我們有一個初始化

731
00:22:12,700 --> 00:22:13,700
那初始化呢

732
00:22:13,700 --> 00:22:15,700
我們就先reset所有的點

733
00:22:15,700 --> 00:22:17,700
它的distance label

734
00:22:17,700 --> 00:22:20,700
distance label代表的就是從原點

735
00:22:20,700 --> 00:22:23,700
s到這個點v

736
00:22:23,700 --> 00:22:28,700
請問它最短要幾段edge可以連通

737
00:22:28,700 --> 00:22:30,700
一開始我們就還不知道嗎

738
00:22:30,700 --> 00:22:32,700
因為我們一開始我們還沒算呢

739
00:22:32,700 --> 00:22:34,700
所以我們就用一個無限大的概念

740
00:22:34,700 --> 00:22:37,700
大家記住m的意思就是無限大的概念

741
00:22:37,700 --> 00:22:40,700
好 那所以一開始因為我都還沒有touch

742
00:22:40,700 --> 00:22:42,700
所以一定是大家都無限大囉

743
00:22:42,700 --> 00:22:46,700
好 那除了原點之外原點就是s

744
00:22:46,700 --> 00:22:48,700
所以它distance label是0啊

745
00:22:48,700 --> 00:22:50,700
那原點的前面當然是什麼都沒有啊

746
00:22:50,700 --> 00:22:53,700
好 然後你就把原點加入我們叫做一個

747
00:22:53,700 --> 00:22:55,700
籃子list

748
00:22:55,700 --> 00:22:58,700
那現在其實就是這個籃子呢是一個q

749
00:22:58,700 --> 00:23:01,700
這個籃子就長在這邊這就是list

750
00:23:01,700 --> 00:23:03,700
所以一開始你就把s放進去這個籃子

751
00:23:03,700 --> 00:23:06,700
好 然後整個的演算法就是在看說

752
00:23:06,700 --> 00:23:09,700
只要籃子還有東西意思就是說

753
00:23:09,700 --> 00:23:13,700
我還有點可以被我選來當起點的意思

754
00:23:13,700 --> 00:23:15,700
好 所以這個籃子就等同於你要去儲存

755
00:23:15,700 --> 00:23:17,700
你的起點是誰

756
00:23:17,700 --> 00:23:22,700
好 那如果以BFS我們把這個籃子視同為一個q的概念

757
00:23:22,700 --> 00:23:25,700
也就是你先進來的你就先壓箱

758
00:23:25,700 --> 00:23:27,700
先壓箱可是等一下你先出去了

759
00:23:27,700 --> 00:23:29,700
好 大概是這個概念

760
00:23:29,700 --> 00:23:31,700
所以我一開始先放s進來

761
00:23:31,700 --> 00:23:35,700
所以現在籃子裡面這個q裡面有一個s

762
00:23:35,700 --> 00:23:38,700
然後它就還不是空的嗎

763
00:23:38,700 --> 00:23:40,700
所以我就可以繼續做事

764
00:23:40,700 --> 00:23:42,700
第一件事情我就把它拿出來

765
00:23:42,700 --> 00:23:44,700
我把它拿出來它就變空了對不對

766
00:23:44,700 --> 00:23:46,700
好 拿出來在要幹嘛

767
00:23:46,700 --> 00:23:49,700
在就是這邊是用一個file

768
00:23:49,700 --> 00:23:51,700
看你要用file或fold都可以的

769
00:23:51,700 --> 00:23:52,700
總之它是一個回圈

770
00:23:52,700 --> 00:23:55,700
它要做的事情呢就是我站在這個點

771
00:23:55,700 --> 00:23:57,700
目前點i

772
00:23:57,700 --> 00:23:59,700
i其實一開始就是s

773
00:23:59,700 --> 00:24:00,700
一開始就s不管

774
00:24:00,700 --> 00:24:02,700
然後你就是看說我站在i

775
00:24:02,700 --> 00:24:04,700
請問有沒有admissible

776
00:24:04,700 --> 00:24:08,700
它的意思就是有沒有

777
00:24:08,700 --> 00:24:10,700
我現在已經i既然被我站在這邊了

778
00:24:10,700 --> 00:24:13,700
當然它就是我們剛才所謂的紅色

779
00:24:13,700 --> 00:24:15,700
也就是被我mark

780
00:24:15,700 --> 00:24:17,700
已經被我visit過了

781
00:24:17,700 --> 00:24:19,700
請問有沒有我這一頭

782
00:24:19,700 --> 00:24:22,700
當然是我已經visit過

783
00:24:22,700 --> 00:24:24,700
有沒有對方那頭還沒有visit過的

784
00:24:24,700 --> 00:24:26,700
如果有的話

785
00:24:26,700 --> 00:24:29,700
我就選其中的一條

786
00:24:29,700 --> 00:24:32,700
好 那譬如說我如果degree是3

787
00:24:32,700 --> 00:24:34,700
我就先選第一條

788
00:24:34,700 --> 00:24:36,700
我選了第一條之後呢

789
00:24:36,700 --> 00:24:38,700
對方那一頭對方那一頭就j

790
00:24:38,700 --> 00:24:40,700
因為這是i到j

791
00:24:40,700 --> 00:24:42,700
所以這個是i對方那一頭是j

792
00:24:42,700 --> 00:24:44,700
對方那一頭的distance label

793
00:24:44,700 --> 00:24:46,700
我就把它reset

794
00:24:46,700 --> 00:24:48,700
變成我當下的distance label再加1

795
00:24:48,700 --> 00:24:51,700
因為那就代表我經過了一段edge的意思

796
00:24:51,700 --> 00:24:54,700
然後對方那一頭的precessor就要設為我

797
00:24:54,700 --> 00:24:56,700
因為它是我來touch它的

798
00:24:56,700 --> 00:24:57,700
既然是我touch它

799
00:24:57,700 --> 00:24:59,700
對方那一頭的precessor

800
00:24:59,700 --> 00:25:00,700
當然就是我

801
00:25:00,700 --> 00:25:01,700
我就是i

802
00:25:01,700 --> 00:25:04,700
然後我新touch到了一個點

803
00:25:04,700 --> 00:25:06,700
這個點是新的

804
00:25:06,700 --> 00:25:08,700
我就把它加入我的籃子

805
00:25:08,700 --> 00:25:09,700
就這樣

806
00:25:09,700 --> 00:25:13,700
然後這一段就是被我scan過了

807
00:25:13,700 --> 00:25:14,700
ok

808
00:25:14,700 --> 00:25:16,700
然後我再重複做這件事

809
00:25:16,700 --> 00:25:17,700
請問還有沒有

810
00:25:17,700 --> 00:25:18,700
站在i還有沒有

811
00:25:18,700 --> 00:25:20,700
下一個edge

812
00:25:20,700 --> 00:25:22,700
是admissible的

813
00:25:22,700 --> 00:25:23,700
如果以我這邊舉例

814
00:25:23,700 --> 00:25:24,700
有這一個

815
00:25:24,700 --> 00:25:25,700
好 

816
00:25:25,700 --> 00:25:27,700
那你就重複做同樣的事

817
00:25:27,700 --> 00:25:29,700
再做完再下一個

818
00:25:29,700 --> 00:25:31,700
再做同樣的事

819
00:25:31,700 --> 00:25:33,700
等到這三個都做完的話

820
00:25:33,700 --> 00:25:34,700
請問還有沒有下一個

821
00:25:34,700 --> 00:25:35,700
你就發現沒有了

822
00:25:35,700 --> 00:25:37,700
因為站在i

823
00:25:37,700 --> 00:25:40,700
它所有的edge都不是admissible了

824
00:25:40,700 --> 00:25:41,700
為什麼不是admissible

825
00:25:41,700 --> 00:25:44,700
因為它的對方那邊都已經被你拜訪過了

826
00:25:44,700 --> 00:25:46,700
所以它就不是admissible了

827
00:25:46,700 --> 00:25:48,700
這樣大家理解

828
00:25:48,700 --> 00:25:51,700
我這邊算是有定義了這些所謂的admissible

829
00:25:51,700 --> 00:25:52,700
or not

830
00:25:52,700 --> 00:25:54,700
當然各位如果在實作

831
00:25:54,700 --> 00:25:56,700
這整個演算法的過程當中

832
00:25:56,700 --> 00:25:58,700
你可以依你的喜歡

833
00:25:58,700 --> 00:25:59,700
看你要怎麼做這些事情

834
00:25:59,700 --> 00:26:03,700
不用一板一眼的照這樣子去做

835
00:26:03,700 --> 00:26:05,700
總之可以達到你的目的就好 

836
00:26:05,700 --> 00:26:08,700
那可是起碼我們這邊所寫的QR code

837
00:26:08,700 --> 00:26:10,700
你應該要看得懂它的意思

838
00:26:10,700 --> 00:26:11,700
好 

839
00:26:11,700 --> 00:26:15,700
總之我們如果把這個degree的這邊通通都掃完了

840
00:26:15,700 --> 00:26:17,700
那意思就是跳出這個file回圈

841
00:26:17,700 --> 00:26:19,700
那跳出這個file回圈之後

842
00:26:19,700 --> 00:26:20,700
它再往上一層

843
00:26:20,700 --> 00:26:22,700
就是往上一層的file

844
00:26:22,700 --> 00:26:26,700
所以這個時候它又要去選一個新的起點

845
00:26:26,700 --> 00:26:28,700
就是我們剛才講的

846
00:26:28,700 --> 00:26:31,700
也就是我們剛才把這個i殺掉之後

847
00:26:31,700 --> 00:26:34,700
我們不是會有加一些j進來嗎

848
00:26:34,700 --> 00:26:38,700
那然後就是那些誰排名第一的

849
00:26:38,700 --> 00:26:41,700
也就是誰第一個被我拜訪過的

850
00:26:41,700 --> 00:26:44,700
它就拿來當新的起點

851
00:26:44,700 --> 00:26:47,700
然後我就repeat了剛才這件事情

852
00:26:47,700 --> 00:26:49,700
所以概念上就會變成我剛才講的

853
00:26:49,700 --> 00:26:52,700
直覺上就是我在這個點可以touch都touch完

854
00:26:52,700 --> 00:26:54,700
然後再依序選新的起點

855
00:26:54,700 --> 00:26:56,700
然後再把它可以touch都touch完

856
00:26:56,700 --> 00:26:58,700
它可以touch都touch完

857
00:26:58,700 --> 00:27:01,700
這些點一定是排在它前面

858
00:27:01,700 --> 00:27:04,700
還沒有被它拿來當起點的後面

859
00:27:04,700 --> 00:27:08,700
所以等一下一定就是會跟它同一層的下一個點

860
00:27:08,700 --> 00:27:10,700
當起點去touch完

861
00:27:10,700 --> 00:27:14,700
然後一樣在同一層的下一個點先touch完

862
00:27:14,700 --> 00:27:15,700
然後才到

863
00:27:15,700 --> 00:27:18,700
所以同一層的一定要全部都當個起點

864
00:27:18,700 --> 00:27:21,700
才輪得到下一層來當起點

865
00:27:21,700 --> 00:27:23,700
那就這樣而已

866
00:27:23,700 --> 00:27:24,700
那你就這樣一直做一直做

867
00:27:24,700 --> 00:27:26,700
做到有朝一日

868
00:27:26,700 --> 00:27:28,700
有朝一日那個list就會變空

869
00:27:28,700 --> 00:27:30,700
我們剛才不是demo過這個例子

870
00:27:30,700 --> 00:27:33,700
那做完了之後後面的這邊呢

871
00:27:33,700 --> 00:27:37,700
其實是要去把你的這個path把它trace出來而已

872
00:27:37,700 --> 00:27:39,700
所以後面這邊你也可以不用做

873
00:27:39,700 --> 00:27:41,700
後面這邊只是單純在講說

874
00:27:41,700 --> 00:27:45,700
請把你的那個path把它展開給我看

875
00:27:45,700 --> 00:27:47,700
你要怎麼展開

876
00:27:47,700 --> 00:27:48,700
那你就可以用

877
00:27:48,700 --> 00:27:51,700
對於任何一個點i來講

878
00:27:51,700 --> 00:27:54,700
那我可以去call這個function

879
00:27:54,700 --> 00:27:56,700
這個function我們要稱之為tracepath

880
00:27:56,700 --> 00:27:58,700
起點是s

881
00:27:58,700 --> 00:28:00,700
那終點是i

882
00:28:00,700 --> 00:28:02,700
那它就會把它call出來

883
00:28:02,700 --> 00:28:06,700
它call出來是我是把它寫在後面那邊

884
00:28:06,700 --> 00:28:10,700
這邊的這個過程我們就先忽略

885
00:28:10,700 --> 00:28:14,700
不過我們先直接看那個trace的那個東西

886
00:28:14,700 --> 00:28:15,700
好 

887
00:28:15,700 --> 00:28:17,700
trace的

888
00:28:17,700 --> 00:28:19,700
trace這邊我沒寫

889
00:28:19,700 --> 00:28:21,700
好 

890
00:28:21,700 --> 00:28:23,700
所以trace我用說明就好 

891
00:28:23,700 --> 00:28:27,700
因為那個其實很容易就可以講解了

892
00:28:27,700 --> 00:28:28,700
ok

893
00:28:28,700 --> 00:28:31,700
好 這個trace這個其實大家可以想像

894
00:28:31,700 --> 00:28:35,700
它應該是一個while loop或for loop的動作了

895
00:28:35,700 --> 00:28:37,700
它的意思大概就是我站在i

896
00:28:37,700 --> 00:28:39,700
請問它的predecessor是誰

897
00:28:39,700 --> 00:28:41,700
那你就把印出來

898
00:28:41,700 --> 00:28:43,700
當然就是predecessor i嘛

899
00:28:43,700 --> 00:28:46,700
那請問predecessor i的predecessor是誰

900
00:28:46,700 --> 00:28:49,700
那當然就是pre的pre的i

901
00:28:49,700 --> 00:28:50,700
我們剛才講過了

902
00:28:50,700 --> 00:28:51,700
好 

903
00:28:51,700 --> 00:28:52,700
ok當然你在寫程式

904
00:28:52,700 --> 00:28:53,700
你不會這麼笨的寫了

905
00:28:53,700 --> 00:28:55,700
你可以用另外一個

906
00:28:55,700 --> 00:28:58,700
變數來暫存它的predecessor

907
00:28:58,700 --> 00:29:00,700
然後你就重複它這個交替的關係

908
00:29:00,700 --> 00:29:03,700
所以你就一路的往上去trace

909
00:29:03,700 --> 00:29:04,700
直到你touch到了s

910
00:29:04,700 --> 00:29:05,700
為什麼

911
00:29:05,700 --> 00:29:06,700
因為s就是你的起點嘛

912
00:29:06,700 --> 00:29:10,700
所以如果當你的predecessor是s的時候

913
00:29:10,700 --> 00:29:11,700
你其實就可以stop了

914
00:29:11,700 --> 00:29:12,700
你就不用往上

915
00:29:12,700 --> 00:29:14,700
就算你往上你也沒有辦法

916
00:29:14,700 --> 00:29:15,700
因為你的predecessor

917
00:29:15,700 --> 00:29:17,700
s的predecessor是null

918
00:29:17,700 --> 00:29:19,700
所以看你要怎麼做都可以

919
00:29:19,700 --> 00:29:21,700
總之後面的這個function

920
00:29:21,700 --> 00:29:24,700
它的功能只是要把這一

921
00:29:24,700 --> 00:29:26,700
從s到i的路徑把它印出來

922
00:29:26,700 --> 00:29:27,700
這樣而已

923
00:29:27,700 --> 00:29:29,700
好 

924
00:29:29,700 --> 00:29:33,700
以上就已經說明完我們的pseudocode

925
00:29:33,700 --> 00:29:34,700
好 

926
00:29:34,700 --> 00:29:35,700
那這個pseudocode呢

927
00:29:35,700 --> 00:29:40,700
為了去解釋它的complexity

928
00:29:40,700 --> 00:29:42,700
比較方便起見

929
00:29:42,700 --> 00:29:44,700
我再進一步把這個pseudocode

930
00:29:44,700 --> 00:29:47,700
分成兩個主要的操作

931
00:29:47,700 --> 00:29:49,700
這兩個主要的操作

932
00:29:49,700 --> 00:29:51,700
分別一個叫做vertex selection

933
00:29:51,700 --> 00:29:53,700
一個叫做distance update

934
00:29:53,700 --> 00:29:54,700
ok

935
00:29:54,700 --> 00:29:55,700
好 

936
00:29:55,700 --> 00:29:57,700
那vertex selection其實就這一行

937
00:29:57,700 --> 00:30:00,700
也就是我們每次要選起點

938
00:30:00,700 --> 00:30:01,700
好 

939
00:30:01,700 --> 00:30:03,700
這件事情叫做vertex selection

940
00:30:03,700 --> 00:30:06,700
那distance update其實就把它視為

941
00:30:06,700 --> 00:30:08,700
就是file裡面這邊在做的事情

942
00:30:08,700 --> 00:30:10,700
也就是我們站在那個點

943
00:30:10,700 --> 00:30:14,700
然後去更新對方那一頭的distance level

944
00:30:14,700 --> 00:30:16,700
那我們稱之為distance update

945
00:30:16,700 --> 00:30:17,700
好 

946
00:30:16,700 --> 00:30:17,700
所以你就記住

947
00:30:17,700 --> 00:30:20,700
在我們現在的BFS裡面

948
00:30:20,700 --> 00:30:21,700
好 

949
00:30:21,700 --> 00:30:23,700
概念上你大概可以理解

950
00:30:23,700 --> 00:30:24,700
你用口語的講

951
00:30:24,700 --> 00:30:25,700
大概也都可以理解

952
00:30:25,700 --> 00:30:28,700
那如果要用比較抽象的方式

953
00:30:28,700 --> 00:30:30,700
把它的步驟再把它拆解

954
00:30:30,700 --> 00:30:33,700
可以拆解成兩大步驟

955
00:30:33,700 --> 00:30:36,700
第一個步驟就是你要去選起點

956
00:30:36,700 --> 00:30:38,700
第二個步驟就是站在那個起點

957
00:30:38,700 --> 00:30:42,700
你去更新對方那一頭的distance level

958
00:30:42,700 --> 00:30:43,700
還有predecessor

959
00:30:43,700 --> 00:30:44,700
就這樣

960
00:30:44,700 --> 00:30:45,700
好 

961
00:30:45,700 --> 00:30:50,700
第二個步驟我們稱之為更新距離

962
00:30:50,700 --> 00:30:53,700
簡稱du distance update

963
00:30:53,700 --> 00:30:56,700
啊第一個步驟是你要選誰當起點

964
00:30:56,700 --> 00:31:00,700
所以其實就是這兩個步驟交替進行

965
00:31:00,700 --> 00:31:02,700
選了點當起點之後

966
00:31:02,700 --> 00:31:03,700
你去站在那個點

967
00:31:03,700 --> 00:31:05,700
我把它稱之為scan i

968
00:31:05,700 --> 00:31:06,700
因為你選出來就是i

969
00:31:06,700 --> 00:31:07,700
好 

970
00:31:07,700 --> 00:31:09,700
啊我站在這個i上面

971
00:31:09,700 --> 00:31:13,700
我去scan它所散出去的這些edge

972
00:31:13,700 --> 00:31:15,700
那我們稱之為distance update

973
00:31:15,700 --> 00:31:16,700
好 

974
00:31:16,700 --> 00:31:18,700
那等一下我又選一個新的i

975
00:31:18,700 --> 00:31:21,700
然後再去散出去的再去scan

976
00:31:21,700 --> 00:31:23,700
等一下又選了一個新的i

977
00:31:23,700 --> 00:31:25,700
再去散出去的再scan

978
00:31:25,700 --> 00:31:27,700
大概就是這樣的流程

979
00:31:27,700 --> 00:31:28,700
好 

980
00:31:28,700 --> 00:31:29,700
ok

981
00:31:29,700 --> 00:31:30,700
好 

982
00:31:30,700 --> 00:31:31,700
那然後

983
00:31:31,700 --> 00:31:32,700
 

984
00:31:32,700 --> 00:31:34,700
等一下我們就會用資料結構觀點

985
00:31:34,700 --> 00:31:35,700
再重新解釋一次

986
00:31:35,700 --> 00:31:36,700
好 

987
00:31:36,700 --> 00:31:37,700
那這個資料結構觀點呢

988
00:31:37,700 --> 00:31:40,700
我們就把這個list當成一個queue

989
00:31:40,700 --> 00:31:41,700
就是fee for的概念

990
00:31:41,700 --> 00:31:42,700
好 

991
00:31:42,700 --> 00:31:44,700
然後我們就用同樣的例子

992
00:31:44,700 --> 00:31:46,700
只是在這邊這樣子解讀

993
00:31:46,700 --> 00:31:47,700
好 

994
00:31:47,700 --> 00:31:48,700
首先我們這個

995
00:31:48,700 --> 00:31:50,700
 根據我們剛才的演算法

996
00:31:50,700 --> 00:31:51,700
好 

997
00:31:51,700 --> 00:31:52,700
我們的list

998
00:31:52,700 --> 00:31:53,700
就是這個queue

999
00:31:53,700 --> 00:31:54,700
好 

1000
00:31:54,700 --> 00:31:55,700
我們先把 原點

1001
00:31:55,700 --> 00:31:57,700
也就是最開始的起點

1002
00:31:57,700 --> 00:31:58,700
好 

1003
00:31:58,700 --> 00:31:58,700
放進去

1004
00:31:58,700 --> 00:31:59,700
好 

1005
00:31:59,700 --> 00:32:00,700
然後我們就會把它

1006
00:32:00,700 --> 00:32:01,700
刪掉了

1007
00:32:01,700 --> 00:32:02,700
好 

1008
00:32:02,700 --> 00:32:04,700
哎其實你三不三都可以了

1009
00:32:04,700 --> 00:32:05,700
就是你要先刪還是後刪

1010
00:32:05,700 --> 00:32:06,700
如果以我們剛才講的

1011
00:32:06,700 --> 00:32:08,700
我感覺好 像是先刪

1012
00:32:08,700 --> 00:32:09,700
好 

1013
00:32:09,700 --> 00:32:11,700
那在這邊demo好 像變成後刪這樣子

1014
00:32:11,700 --> 00:32:12,700
啊什麼意思

1015
00:32:12,700 --> 00:32:15,700
就是這邊我們剛才的動作呢

1016
00:32:15,700 --> 00:32:16,700
就是把

1017
00:32:16,700 --> 00:32:18,700
 站在你的這個i

1018
00:32:18,700 --> 00:32:19,700
好 

1019
00:32:19,700 --> 00:32:20,700
然後就是去scan

1020
00:32:20,700 --> 00:32:21,700
好 

1021
00:32:21,700 --> 00:32:22,700
那其實就是distance update

1022
00:32:22,700 --> 00:32:23,700
哎

1023
00:32:23,700 --> 00:32:25,700
然後你就把最新touch到的就放啊

1024
00:32:25,700 --> 00:32:27,700
放依序放到籃子

1025
00:32:27,700 --> 00:32:28,700
所以我先touch到2

1026
00:32:28,700 --> 00:32:30,700
我就把2放到了q

1027
00:32:30,700 --> 00:32:32,700
再來我又touch到5

1028
00:32:32,700 --> 00:32:33,700
我就把5放到q

1029
00:32:33,700 --> 00:32:35,700
再來我又touch到3

1030
00:32:35,700 --> 00:32:36,700
我就把3放到q

1031
00:32:36,700 --> 00:32:37,700
好 

1032
00:32:37,700 --> 00:32:39,700
然後我依舊攻城勝退

1033
00:32:39,700 --> 00:32:40,700
依舊可以刪掉

1034
00:32:40,700 --> 00:32:41,700
好 

1035
00:32:41,700 --> 00:32:42,700
那你如果看我們的演算法

1036
00:32:42,700 --> 00:32:44,700
感覺好 像是它先殺掉

1037
00:32:44,700 --> 00:32:45,700
再來做這件事

1038
00:32:45,700 --> 00:32:46,700
其實都可以啦

1039
00:32:46,700 --> 00:32:48,700
反正你自己不要搞錯就好 

1040
00:32:48,700 --> 00:32:49,700
好 

1041
00:32:49,700 --> 00:32:49,700
那在我這邊的demo

1042
00:32:49,700 --> 00:32:51,700
我是好 像先掃完

1043
00:32:51,700 --> 00:32:52,700
我才把它刪

1044
00:32:52,700 --> 00:32:53,700
好 

1045
00:32:53,700 --> 00:32:53,700
好 

1046
00:32:53,700 --> 00:32:54,700
那這樣刪完之後

1047
00:32:54,700 --> 00:32:55,700
請問帶頭大哥是誰

1048
00:32:55,700 --> 00:32:56,700
那當然就是

1049
00:32:56,700 --> 00:32:58,700
Q裡面的最前面的一個

1050
00:32:58,700 --> 00:32:59,700
好 

1051
00:32:59,700 --> 00:32:59,700
那就是2了

1052
00:32:59,700 --> 00:33:00,700
好 

1053
00:33:00,700 --> 00:33:02,700
那所以我們在2再重做這件事

1054
00:33:02,700 --> 00:33:04,700
然後就把4放進來

1055
00:33:04,700 --> 00:33:05,700
那因為是q

1056
00:33:05,700 --> 00:33:06,700
所以就擺在後面了

1057
00:33:06,700 --> 00:33:07,700
嘿

1058
00:33:07,700 --> 00:33:08,700
然後再來呢

1059
00:33:08,700 --> 00:33:09,700
2已經攻城勝退了

1060
00:33:09,700 --> 00:33:10,700
好 

1061
00:33:10,700 --> 00:33:11,700
所以2又被我刪掉了

1062
00:33:11,700 --> 00:33:13,700
再帶頭大哥就變5了

1063
00:33:13,700 --> 00:33:14,700
好 

1064
00:33:14,700 --> 00:33:14,700
所以

1065
00:33:14,700 --> 00:33:16,700
哎我們剛才用圖形的方式

1066
00:33:16,700 --> 00:33:18,700
是因為我們可以用畫的

1067
00:33:18,700 --> 00:33:20,700
然後我們用視覺

1068
00:33:20,700 --> 00:33:21,700
目視法

1069
00:33:21,700 --> 00:33:22,700
我們來判斷

1070
00:33:22,700 --> 00:33:24,700
我們用我們的記憶力

1071
00:33:24,700 --> 00:33:27,700
知道說先做2再做5再做3

1072
00:33:27,700 --> 00:33:28,700
那你要想像一下

1073
00:33:28,700 --> 00:33:30,700
如果你今天要處理的是什麼

1074
00:33:30,700 --> 00:33:31,700
1萬個vertex

1075
00:33:31,700 --> 00:33:33,700
啊100萬個edge之類的

1076
00:33:33,700 --> 00:33:35,700
哇我哪有那種記憶力

1077
00:33:35,700 --> 00:33:36,700
對不對

1078
00:33:36,700 --> 00:33:38,700
然後再給它想說是電腦在做的

1079
00:33:38,700 --> 00:33:40,700
請問電腦怎麼知道誰在前面

1080
00:33:40,700 --> 00:33:41,700
誰在後面呢

1081
00:33:41,700 --> 00:33:42,700
那

1082
00:33:42,700 --> 00:33:45,700
那這就是為什麼我們要講q

1083
00:33:45,700 --> 00:33:49,700
因為你就把電腦做這件事情的執行方式

1084
00:33:49,700 --> 00:33:50,700
用q來做

1085
00:33:50,700 --> 00:33:53,700
它剛好 就是會做我們剛才所講的這個動作

1086
00:33:53,700 --> 00:33:55,700
也就是誰先進去

1087
00:33:55,700 --> 00:33:56,700
誰就排在前面

1088
00:33:56,700 --> 00:33:57,700
誰後進去

1089
00:33:57,700 --> 00:33:58,700
誰就排在後面

1090
00:33:58,700 --> 00:34:00,700
所以1我們剛才所講

1091
00:34:00,700 --> 00:34:01,700
2先進去

1092
00:34:01,700 --> 00:34:02,700
2就先結束了

1093
00:34:02,700 --> 00:34:04,700
然後再來我們帶頭大哥

1094
00:34:04,700 --> 00:34:07,700
當然就變成剛才的第二個進來的5

1095
00:34:07,700 --> 00:34:09,700
那5進來了

1096
00:34:09,700 --> 00:34:11,700
它現在是當帶頭大哥了

1097
00:34:11,700 --> 00:34:14,700
那當然我們就正在5去scan

1098
00:34:14,700 --> 00:34:15,700
所以6就放進來了

1099
00:34:15,700 --> 00:34:17,700
然後5就可以刪掉了

1100
00:34:17,700 --> 00:34:19,700
那5刪掉之後

1101
00:34:19,700 --> 00:34:21,700
再來就變成帶頭大哥是3了

1102
00:34:21,700 --> 00:34:25,700
結果你發現說3都沒有辦法把新的點放進來

1103
00:34:25,700 --> 00:34:27,700
所以它就直接就刪除了

1104
00:34:27,700 --> 00:34:29,700
然後再帶頭大哥是4

1105
00:34:29,700 --> 00:34:31,700
當然這個時候我們用目視法就知道說

1106
00:34:31,700 --> 00:34:33,700
我們第一層已經結束了

1107
00:34:33,700 --> 00:34:34,700
我們現在在第二層4

1108
00:34:34,700 --> 00:34:36,700
然後4它可以把8放進來

1109
00:34:36,700 --> 00:34:38,700
那你就把8放進來囉

1110
00:34:38,700 --> 00:34:39,700
然後4又結束了

1111
00:34:39,700 --> 00:34:42,700
因為它已經scan不到別人了

1112
00:34:42,700 --> 00:34:44,700
那再來就是新的帶頭大哥是6

1113
00:34:44,700 --> 00:34:46,700
6可以把7跟9都放進來

1114
00:34:46,700 --> 00:34:48,700
所以6就結束了

1115
00:34:48,700 --> 00:34:49,700
剛才老師也有提過

1116
00:34:49,700 --> 00:34:51,700
我們用目視法其實就知道說

1117
00:34:51,700 --> 00:34:52,700
其實已經做完了

1118
00:34:52,700 --> 00:34:54,700
再做也是枉然

1119
00:34:54,700 --> 00:34:55,700
不過正在電腦的觀點

1120
00:34:55,700 --> 00:34:58,700
它要有一致的結束的判斷方式

1121
00:34:58,700 --> 00:35:00,700
所以它就單純看說

1122
00:35:00,700 --> 00:35:02,700
請問還有東西可以當起點嗎

1123
00:35:02,700 --> 00:35:03,700
答案有

1124
00:35:03,700 --> 00:35:05,700
那既然有我們就做

1125
00:35:05,700 --> 00:35:07,700
所以就站在8

1126
00:35:07,700 --> 00:35:09,700
站在8我們當然用目視法知道說

1127
00:35:09,700 --> 00:35:13,700
它誰都沒有辦法再新touch到新的點了嗎

1128
00:35:13,700 --> 00:35:15,700
那7也是一樣

1129
00:35:15,700 --> 00:35:16,700
9也是一樣

1130
00:35:16,700 --> 00:35:21,700
哇終於大家都沒有在我們的籃子裡了

1131
00:35:21,700 --> 00:35:23,700
所以剛才那個籃子就等同於是

1132
00:35:23,700 --> 00:35:25,700
我可以touch到我就拿來當起點

1133
00:35:25,700 --> 00:35:27,700
我可以touch到我就拿來當起點

1134
00:35:27,700 --> 00:35:28,700
而且是依序

1135
00:35:28,700 --> 00:35:31,700
所以如果這邊通通都結束了

1136
00:35:31,700 --> 00:35:33,700
直覺上就是其它的點

1137
00:35:33,700 --> 00:35:37,700
都是我沒有辦法touch到的

1138
00:35:37,700 --> 00:35:39,700
只要可以touch到的

1139
00:35:39,700 --> 00:35:43,700
就會被我放到籃子裡面過

1140
00:35:43,700 --> 00:35:46,700
這樣也就是現在大家看到的圖

1141
00:35:46,700 --> 00:35:49,700
就是紅色這一點

1142
00:35:49,700 --> 00:35:51,700
所以這樣的過程

1143
00:35:51,700 --> 00:35:53,700
是不是就是可以把給定一個起點

1144
00:35:53,700 --> 00:35:55,700
它可以touch到的所有的點

1145
00:35:55,700 --> 00:35:57,700
通通都touch到

1146
00:35:57,700 --> 00:36:00,700
而且它有一個順序

1147
00:36:00,700 --> 00:36:03,700
然後剛好 它所touch的

1148
00:36:03,700 --> 00:36:07,700
我們剛才講的就是一層兩層三層的關係

1149
00:36:07,700 --> 00:36:11,700
剛好 這個就是最短路徑

1150
00:36:11,700 --> 00:36:14,700
也就是最短要幾段edge

1151
00:36:14,700 --> 00:36:15,700
可以touch到那個點

1152
00:36:15,700 --> 00:36:17,700
the distance label

1153
00:36:17,700 --> 00:36:19,700
ok好 

1154
00:36:19,700 --> 00:36:23,700
那這是最短路徑

1155
00:36:23,700 --> 00:36:25,700
我們就順便講完了

1156
00:36:25,700 --> 00:36:27,700
那其實要去證明它是最短路徑

1157
00:36:27,700 --> 00:36:29,700
可能還要花一些時間講

1158
00:36:29,700 --> 00:36:32,700
不過我在這個部分我就不講

1159
00:36:32,700 --> 00:36:34,700
因為我想說這個其實還蠻符合直覺

1160
00:36:34,700 --> 00:36:37,700
因為有點像說你可以touch到

1161
00:36:37,700 --> 00:36:39,700
你就優先touch它了

1162
00:36:39,700 --> 00:36:43,700
所以你沒有辦法找到一個更短的touch到方法

1163
00:36:43,700 --> 00:36:46,700
ok直覺大概是這樣

1164
00:36:46,700 --> 00:36:49,700
那我們如果把剛才的predecessor

1165
00:36:49,700 --> 00:36:51,700
所構成的關係

1166
00:36:51,700 --> 00:36:54,700
也就是大家在這一頁上看到的

1167
00:36:54,700 --> 00:36:56,700
比較粗的線

1168
00:36:56,700 --> 00:36:59,700
那它就構成了我們稱之為BFS tree

1169
00:36:59,700 --> 00:37:00,700
好 

1170
00:37:00,700 --> 00:37:02,700
ok它是一個tree

1171
00:37:02,700 --> 00:37:04,700
啊什麼是tree

1172
00:37:04,700 --> 00:37:06,700
tree就是一個connected的圖

1173
00:37:06,700 --> 00:37:08,700
然後它沒有cycle

1174
00:37:08,700 --> 00:37:09,700
ok

1175
00:37:09,700 --> 00:37:11,700
所以大家如果只看這個

1176
00:37:11,700 --> 00:37:13,700
這些edge

1177
00:37:13,700 --> 00:37:16,700
它是不是touch到所有的點

1178
00:37:16,700 --> 00:37:17,700
好 

1179
00:37:17,700 --> 00:37:20,700
啊其實它是一個spanning tree

1180
00:37:20,700 --> 00:37:21,700
好 ok

1181
00:37:21,700 --> 00:37:24,700
不見得每一個例子都是spanning tree

1182
00:37:24,700 --> 00:37:26,700
在這個例子剛好 是

1183
00:37:26,700 --> 00:37:30,700
因為它剛好 方向可以讓它可以touch到所有的點

1184
00:37:30,700 --> 00:37:31,700
好 

1185
00:37:31,700 --> 00:37:32,700
那

1186
00:37:32,700 --> 00:37:35,700
然後你在這個path上面

1187
00:37:35,700 --> 00:37:37,700
其實它就是shortest path

1188
00:37:37,700 --> 00:37:38,700
好 

1189
00:37:38,700 --> 00:37:40,700
然後這裡有一些exercise

1190
00:37:40,700 --> 00:37:41,700
這邊我就

1191
00:37:41,700 --> 00:37:43,700
不demo了

1192
00:37:43,700 --> 00:37:45,700
這邊大家就自己去demo了

1193
00:37:45,700 --> 00:37:46,700
我就自己去練習

1194
00:37:46,700 --> 00:37:49,700
看說你的順序是怎麼樣

1195
00:37:49,700 --> 00:37:52,700
這個當然考試都一定必考

1196
00:37:52,700 --> 00:37:55,700
那這種都是要送分給大家的

1197
00:37:55,700 --> 00:37:58,700
當然你自己要有一個準

1198
00:37:58,700 --> 00:37:59,700
我的意思說

1199
00:37:59,700 --> 00:38:00,700
舉例來講

1200
00:38:00,700 --> 00:38:03,700
我現在我如果隨便舉例

1201
00:38:03,700 --> 00:38:05,700
譬如說像這個我站在G這個點

1202
00:38:05,700 --> 00:38:07,700
我站在G這個點

1203
00:38:07,700 --> 00:38:09,700
假設我當初是從O連過來的

1204
00:38:09,700 --> 00:38:11,700
然後我們目視法

1205
00:38:11,700 --> 00:38:12,700
站在G這個點

1206
00:38:12,700 --> 00:38:14,700
我們至少知道說B

1207
00:38:14,700 --> 00:38:15,700
H

1208
00:38:15,700 --> 00:38:17,700
K我都可以去touch它

1209
00:38:17,700 --> 00:38:19,700
請問你要先touch誰

1210
00:38:19,700 --> 00:38:20,700
那如果依老師的說法

1211
00:38:20,700 --> 00:38:21,700
其實沒有一個準

1212
00:38:21,700 --> 00:38:22,700
好 

1213
00:38:22,700 --> 00:38:23,700
那考試的時候

1214
00:38:23,700 --> 00:38:27,700
有可能它會因為它要評分的需求

1215
00:38:27,700 --> 00:38:28,700
好 

1216
00:38:28,700 --> 00:38:30,700
那大家大家要有一致的標準

1217
00:38:30,700 --> 00:38:32,700
所以它可能就會說好 

1218
00:38:32,700 --> 00:38:35,700
當你有multiple choice的時候

1219
00:38:35,700 --> 00:38:38,700
以這個例子就是BHK都可以選

1220
00:38:38,700 --> 00:38:42,700
請用alphabetical order這樣來選

1221
00:38:42,700 --> 00:38:44,700
如果它已經明確告訴你

1222
00:38:44,700 --> 00:38:45,700
好 

1223
00:38:45,700 --> 00:38:49,700
那當然你就要EBHK的順序來選

1224
00:38:49,700 --> 00:38:51,700
因為這就是alphabetical order

1225
00:38:51,700 --> 00:38:52,700
如果它沒有講的話

1226
00:38:52,700 --> 00:38:54,700
你可以隨便你

1227
00:38:54,700 --> 00:38:55,700
好 

1228
00:38:55,700 --> 00:38:56,700
那

1229
00:38:56,700 --> 00:39:01,700
那這個練習就大家自己練

1230
00:39:01,700 --> 00:39:02,700
好 

1231
00:39:02,700 --> 00:39:05,700
然後最後我們這邊要講的是BFS

1232
00:39:05,700 --> 00:39:07,700
請問它的complexity是多少

1233
00:39:07,700 --> 00:39:09,700
ok

1234
00:39:09,700 --> 00:39:10,700
好 

1235
00:39:10,700 --> 00:39:11,700
那

1236
00:39:11,700 --> 00:39:14,700
它complexity如果從我們剛才所講的

1237
00:39:14,700 --> 00:39:16,700
它就是兩大步驟

1238
00:39:16,700 --> 00:39:17,700
vertex selection

1239
00:39:17,700 --> 00:39:19,700
選誰當起點

1240
00:39:19,700 --> 00:39:21,700
在第二個步驟就distance update

1241
00:39:21,700 --> 00:39:24,700
就是站在那個點你去scan

1242
00:39:24,700 --> 00:39:25,700
好 

1243
00:39:25,700 --> 00:39:29,700
那我們這邊是先定義了我們的名詞

1244
00:39:29,700 --> 00:39:32,700
當我們說我在scan一個vertex i的意思

1245
00:39:32,700 --> 00:39:36,700
我的意思就是去scan它所有出去的這些edge

1246
00:39:36,700 --> 00:39:39,700
我們稱之為scan vertex i

1247
00:39:39,700 --> 00:39:43,700
那當我在說我scan這個i這段edge的時候

1248
00:39:43,700 --> 00:39:46,700
我的意思就是要去檢查看看說

1249
00:39:46,700 --> 00:39:49,700
請問這個edge我到底對方這一頭

1250
00:39:49,700 --> 00:39:52,700
是否我還沒有被mark到

1251
00:39:52,700 --> 00:39:53,700
ok

1252
00:39:53,700 --> 00:39:54,700
好 

1253
00:39:54,700 --> 00:39:57,700
我剛才其實一開始定義了這個無限大

1254
00:39:57,700 --> 00:39:59,700
然後後來都沒有去特別講

1255
00:39:59,700 --> 00:40:02,700
你怎麼知道對方這一頭

1256
00:40:02,700 --> 00:40:03,700
你還沒touch到

1257
00:40:03,700 --> 00:40:05,700
其中一個判斷方式就是

1258
00:40:05,700 --> 00:40:08,700
如果它還是無限大的概念

1259
00:40:08,700 --> 00:40:11,700
那它當然就是還沒被你touch到

1260
00:40:11,700 --> 00:40:14,700
因為如果是一個有限的數字

1261
00:40:14,700 --> 00:40:17,700
當然你可能會說老師我們都不是有限的數字

1262
00:40:17,700 --> 00:40:20,700
我要講的是說只要它不是M

1263
00:40:20,700 --> 00:40:22,700
M把它理解為無限大

1264
00:40:22,700 --> 00:40:24,700
那如果是有限的數字

1265
00:40:24,700 --> 00:40:26,700
就是類似123457

1266
00:40:26,700 --> 00:40:28,700
就是剛才的更新

1267
00:40:28,700 --> 00:40:30,700
那就代表有被你touch到了

1268
00:40:30,700 --> 00:40:31,700
好 

1269
00:40:31,700 --> 00:40:31,700
ok

1270
00:40:31,700 --> 00:40:34,700
所以當我在講scan edge i的時候

1271
00:40:34,700 --> 00:40:38,700
其實就是要去做那個演算法裡面

1272
00:40:38,700 --> 00:40:40,700
我要去檢查站在i

1273
00:40:40,700 --> 00:40:43,700
要檢查i這一段的那件事情

1274
00:40:43,700 --> 00:40:44,700
好 

1275
00:40:44,700 --> 00:40:45,700
ok

1276
00:40:45,700 --> 00:40:49,700
其實就是你要去看說它是不是admissible

1277
00:40:49,700 --> 00:40:51,700
你要怎麼看它是否admissible

1278
00:40:51,700 --> 00:40:53,700
你其實就要看對方那一頭

1279
00:40:53,700 --> 00:40:55,700
是否

1280
00:40:55,700 --> 00:40:59,700
它的disenable仍然為無限大

1281
00:40:59,700 --> 00:41:00,700
ok

1282
00:41:00,700 --> 00:41:02,700
所以這個我們稱之為scan

1283
00:41:02,700 --> 00:41:03,700
ok

1284
00:41:03,700 --> 00:41:04,700
好 

1285
00:41:04,700 --> 00:41:06,700
如果這樣來定義

1286
00:41:06,700 --> 00:41:08,700
我們的vertex selection

1287
00:41:08,700 --> 00:41:11,700
我們從比較廣的角度來看

1288
00:41:11,700 --> 00:41:16,700
請問一個點會被它選過幾次

1289
00:41:16,700 --> 00:41:18,700
嗯

1290
00:41:18,700 --> 00:41:20,700
剛好 我這邊寫了exactly once

1291
00:41:20,700 --> 00:41:23,700
所謂的exactly once其實要修正一下

1292
00:41:23,700 --> 00:41:26,700
就是如果是一個connected的圖的話

1293
00:41:26,700 --> 00:41:29,700
那它當然它就可以被你connect到

1294
00:41:29,700 --> 00:41:32,700
所以它就會被你拿來當起點

1295
00:41:32,700 --> 00:41:34,700
剛好 一次

1296
00:41:34,700 --> 00:41:36,700
它一旦被你拿來當起點了

1297
00:41:36,700 --> 00:41:39,700
它就不會被你再拿來當起點

1298
00:41:39,700 --> 00:41:41,700
ok

1299
00:41:41,700 --> 00:41:43,700
因為你從我們剛才的操作

1300
00:41:43,700 --> 00:41:46,700
它進入到一個Q裡面之後

1301
00:41:46,700 --> 00:41:47,700
它被刪掉之後

1302
00:41:47,700 --> 00:41:49,700
它還會被加進去嗎

1303
00:41:49,700 --> 00:41:50,700
那答案是不會

1304
00:41:50,700 --> 00:41:52,700
那為什麼你可以確定不會呢

1305
00:41:52,700 --> 00:41:54,700
你可以從它的演算法的流程

1306
00:41:54,700 --> 00:41:56,700
就可以知道說其實是不會的

1307
00:41:56,700 --> 00:41:59,700
因為它如果會把一個點加進Q

1308
00:41:59,700 --> 00:42:03,700
只有在一開始的情況才會加進Q

1309
00:42:03,700 --> 00:42:05,700
怎麼叫一開始的情況

1310
00:42:05,700 --> 00:42:06,700
就這一行

1311
00:42:06,700 --> 00:42:09,700
你要把它加進Q只有在這一行

1312
00:42:09,700 --> 00:42:11,700
這一行就是當它是admissible的時候

1313
00:42:11,700 --> 00:42:13,700
什麼叫它是admissible

1314
00:42:13,700 --> 00:42:15,700
也就是對方J這一頭

1315
00:42:15,700 --> 00:42:17,700
J還沒有被你mark

1316
00:42:17,700 --> 00:42:20,700
也就是剛才的所謂的紅色的意思

1317
00:42:20,700 --> 00:42:25,700
它如果還不是紅色

1318
00:42:25,700 --> 00:42:28,700
那你就有機會把它加進來

1319
00:42:28,700 --> 00:42:29,700
可是當你把它加進來之後

1320
00:42:29,700 --> 00:42:31,700
它就變紅色了

1321
00:42:31,700 --> 00:42:32,700
ok

1322
00:42:32,700 --> 00:42:33,700
它變紅色之後

1323
00:42:33,700 --> 00:42:36,700
它就不可能變成不是紅色

1324
00:42:36,700 --> 00:42:38,700
所以從這個觀點

1325
00:42:38,700 --> 00:42:39,700
你就可以知道說

1326
00:42:39,700 --> 00:42:41,700
一個點一旦被你加進來

1327
00:42:41,700 --> 00:42:43,700
就是它變成紅色

1328
00:42:43,700 --> 00:42:45,700
才被你加進來

1329
00:42:45,700 --> 00:42:46,700
ok

1330
00:42:46,700 --> 00:42:49,700
應該說它從非紅色的

1331
00:42:49,700 --> 00:42:50,700
被你touch到

1332
00:42:50,700 --> 00:42:51,700
你就把它加進來

1333
00:42:51,700 --> 00:42:53,700
把它加進來之後

1334
00:42:53,700 --> 00:42:54,700
它其實就變紅色

1335
00:42:54,700 --> 00:42:56,700
因為它已經被紅色

1336
00:42:56,700 --> 00:42:58,700
所以它永遠不可能再變成

1337
00:42:58,700 --> 00:43:00,700
另外一個admissible edge的

1338
00:43:00,700 --> 00:43:01,700
另外那一頭

1339
00:43:01,700 --> 00:43:04,700
所以總之一個點只會進來一次

1340
00:43:04,700 --> 00:43:06,700
那一個點只會進來一次

1341
00:43:06,700 --> 00:43:08,700
然後我們每次都會刪掉一個點

1342
00:43:08,700 --> 00:43:10,700
所以請問我們這件事情

1343
00:43:10,700 --> 00:43:11,700
總共最後可以做幾次

1344
00:43:11,700 --> 00:43:13,700
答案就是and一次方

1345
00:43:13,700 --> 00:43:15,700
因為一個點就一次

1346
00:43:15,700 --> 00:43:19,700
它就不會無限的循環

1347
00:43:19,700 --> 00:43:20,700
它也不會多於一次

1348
00:43:20,700 --> 00:43:22,700
它就是最多的一次

1349
00:43:22,700 --> 00:43:24,700
所以vertex selection從頭到尾

1350
00:43:24,700 --> 00:43:25,700
總共會做幾次

1351
00:43:25,700 --> 00:43:27,700
答案就是and一次方

1352
00:43:27,700 --> 00:43:30,700
因為一個點會被你選一次

1353
00:43:30,700 --> 00:43:32,700
等一下它工程勝對之後

1354
00:43:32,700 --> 00:43:33,700
不會再被你選了

1355
00:43:33,700 --> 00:43:35,700
總共才and個點而已

1356
00:43:35,700 --> 00:43:37,700
每個點假設都被你這樣做過一次

1357
00:43:37,700 --> 00:43:38,700
那就and一次方

1358
00:43:38,700 --> 00:43:39,700
好 

1359
00:43:39,700 --> 00:43:41,700
然後再來我們要看decent update

1360
00:43:41,700 --> 00:43:42,700
請問它會花多少時間

1361
00:43:42,700 --> 00:43:45,700
ok decent update會花多少時間

1362
00:43:45,700 --> 00:43:47,700
其實就取決於它的操作

1363
00:43:47,700 --> 00:43:49,700
就是站在i要去scan

1364
00:43:49,700 --> 00:43:51,700
它的outgoing的這些edge的

1365
00:43:51,700 --> 00:43:52,700
對方那一頭

1366
00:43:52,700 --> 00:43:54,700
所以從這個觀點來看

1367
00:43:54,700 --> 00:43:56,700
它其實是outdegree

1368
00:43:56,700 --> 00:43:58,700
當然如果我們是無相讀的話

1369
00:43:58,700 --> 00:44:00,700
其實就是degree的意思

1370
00:44:00,700 --> 00:44:01,700
所以它的degree i

1371
00:44:01,700 --> 00:44:02,700
outdegree i

1372
00:44:02,700 --> 00:44:03,700
ok

1373
00:44:03,700 --> 00:44:05,700
所以站在i

1374
00:44:05,700 --> 00:44:06,700
它所花的時間

1375
00:44:06,700 --> 00:44:09,700
就是它到底連了幾條出去

1376
00:44:09,700 --> 00:44:11,700
然後每一個i被你這樣做一次

1377
00:44:11,700 --> 00:44:13,700
所以overall請問

1378
00:44:13,700 --> 00:44:15,700
它從頭到尾到底做了幾次

1379
00:44:15,700 --> 00:44:18,700
答案就是我們之前講過很多次的

1380
00:44:18,700 --> 00:44:20,700
把所有點的outdegree加上起來

1381
00:44:20,700 --> 00:44:21,700
那就是and一次方

1382
00:44:21,700 --> 00:44:23,700
ok

1383
00:44:23,700 --> 00:44:25,700
所以

1384
00:44:25,700 --> 00:44:27,700
decent update從頭到尾

1385
00:44:27,700 --> 00:44:29,700
所做的

1386
00:44:29,700 --> 00:44:31,700
總時間就是and一次方

1387
00:44:31,700 --> 00:44:33,700
那是因為

1388
00:44:33,700 --> 00:44:35,700
你每做一次它

1389
00:44:35,700 --> 00:44:37,700
等同於去掃i的

1390
00:44:37,700 --> 00:44:39,700
出去的某一條

1391
00:44:39,700 --> 00:44:41,700
而你i會結束呢

1392
00:44:41,700 --> 00:44:43,700
就是把它的outdegree都結束

1393
00:44:43,700 --> 00:44:45,700
啊等到它這邊結束之後

1394
00:44:45,700 --> 00:44:47,700
等一下i不會再被你選第二次了

1395
00:44:47,700 --> 00:44:48,700
好 

1396
00:44:48,700 --> 00:44:50,700
所以你下一次就換另外一個點的i

1397
00:44:50,700 --> 00:44:52,700
然後再做一次掃它的outdegree

1398
00:44:52,700 --> 00:44:54,700
所以最壞的情況

1399
00:44:54,700 --> 00:44:55,700
就是把所有點的outdegree

1400
00:44:55,700 --> 00:44:56,700
全部都掃過

1401
00:44:56,700 --> 00:44:58,700
那其實就是所有的edge的意思

1402
00:44:58,700 --> 00:45:00,700
所以

1403
00:45:00,700 --> 00:45:02,700
以complexity來講

1404
00:45:02,700 --> 00:45:04,700
它的decent update

1405
00:45:04,700 --> 00:45:06,700
所花的時間就是and一次方

1406
00:45:06,700 --> 00:45:08,700
然後

1407
00:45:08,700 --> 00:45:10,700
vertex/所花的時間

1408
00:45:10,700 --> 00:45:12,700
是

1409
00:45:12,700 --> 00:45:14,700
and一次方

1410
00:45:14,700 --> 00:45:16,700
ok我剛才講其實講得比較快

1411
00:45:16,700 --> 00:45:18,700
因為我剛才講

1412
00:45:18,700 --> 00:45:20,700
and一次方是概念上是這樣沒錯

1413
00:45:20,700 --> 00:45:22,700
可是你的實作

1414
00:45:22,700 --> 00:45:24,700
有可能不是喔

1415
00:45:24,700 --> 00:45:26,700
如果是用adjacency matrix的話

1416
00:45:26,700 --> 00:45:28,700
你其實剛才的那個

1417
00:45:28,700 --> 00:45:30,700
outdegree這件事情

1418
00:45:30,700 --> 00:45:32,700
我們剛才是所以說

1419
00:45:32,700 --> 00:45:34,700
and一次方是因為基於

1420
00:45:34,700 --> 00:45:36,700
這樣子是and一次方

1421
00:45:36,700 --> 00:45:38,700
可是想像一下如果你今天

1422
00:45:38,700 --> 00:45:40,700
資料結構不是用adjacency

1423
00:45:40,700 --> 00:45:42,700
list

1424
00:45:42,700 --> 00:45:44,700
而是用adjacency matrix的話

1425
00:45:44,700 --> 00:45:46,700
那你光在做

1426
00:45:46,700 --> 00:45:48,700
outdegree這件事情請問你要怎麼做

1427
00:45:48,700 --> 00:45:50,700
你一定就是我正在i這個

1428
00:45:50,700 --> 00:45:52,700
然後我就掃過用一個

1429
00:45:52,700 --> 00:45:54,700
multiple然後你會把那個零的

1430
00:45:54,700 --> 00:45:56,700
也一併掃了

1431
00:45:56,700 --> 00:45:58,700
ok

1432
00:45:58,700 --> 00:46:00,700
所以如果你是用adjacency

1433
00:46:00,700 --> 00:46:02,700
matrix的話其實你的

1434
00:46:02,700 --> 00:46:04,700
這個要去掃outdegree還是花

1435
00:46:04,700 --> 00:46:06,700
and一次方

1436
00:46:06,700 --> 00:46:08,700
如果用adjacency

1437
00:46:08,700 --> 00:46:10,700
list的確它就是

1438
00:46:10,700 --> 00:46:12,700
outdegree only

1439
00:46:12,700 --> 00:46:14,700
所以如果是用adjacency matrix的話

1440
00:46:14,700 --> 00:46:16,700
你其實是比較浪費時間的

1441
00:46:16,700 --> 00:46:18,700
這就是老師一而再再而三

1442
00:46:18,700 --> 00:46:20,700
來跟各位講請勿

1443
00:46:20,700 --> 00:46:22,700
用adjacency matrix來做

1444
00:46:22,700 --> 00:46:24,700
這件事情

1445
00:46:24,700 --> 00:46:26,700
ok所以

1446
00:46:26,700 --> 00:46:28,700
complexity其實會基於

1447
00:46:28,700 --> 00:46:30,700
你的data structure

1448
00:46:30,700 --> 00:46:32,700
會不太一樣如果你是

1449
00:46:32,700 --> 00:46:34,700
用adjacency list的話

1450
00:46:34,700 --> 00:46:36,700
它就and一次方

1451
00:46:36,700 --> 00:46:38,700
如果用adjacency matrix的話

1452
00:46:38,700 --> 00:46:40,700
它就是and平方

1453
00:46:40,700 --> 00:46:42,700
雖然說以big o 來講

1454
00:46:42,700 --> 00:46:44,700
這個and一次方

1455
00:46:44,700 --> 00:46:46,700
它也可以寫成and平方

1456
00:46:46,700 --> 00:46:48,700
當它的上限

1457
00:46:48,700 --> 00:46:50,700
可是and平方不能寫

1458
00:46:50,700 --> 00:46:52,700
當它的上限

1459
00:46:52,700 --> 00:46:54,700
那總之

1460
00:46:54,700 --> 00:46:56,700
就是

1461
00:46:56,700 --> 00:46:58,700
大概是這樣子

1462
00:46:58,700 --> 00:47:00,700
所以我們後來

1463
00:47:00,700 --> 00:47:02,700
就大概都是用and的一次方

1464
00:47:02,700 --> 00:47:04,700
來稱BFS的complexity

1465
00:47:04,700 --> 00:47:06,700
好 

1466
00:47:06,700 --> 00:47:08,700
那最後這邊

1467
00:47:08,700 --> 00:47:10,700
剛才已經有提過

1468
00:47:10,700 --> 00:47:12,700
剛才沒有講的

1469
00:47:12,700 --> 00:47:14,700
就是那個trace你要怎麼做

1470
00:47:14,700 --> 00:47:16,700
剛才有提過了

1471
00:47:16,700 --> 00:47:18,700
就是你的precessor

1472
00:47:18,700 --> 00:47:20,700
一直往前回溯

1473
00:47:20,700 --> 00:47:22,700
只要你碰到了s

1474
00:47:22,700 --> 00:47:24,700
你就可以結束

1475
00:47:24,700 --> 00:47:26,700
因為你就是從終點

1476
00:47:26,700 --> 00:47:28,700
它的precessor

1477
00:47:28,700 --> 00:47:30,700
有朝一日你終於會touch到s

1478
00:47:30,700 --> 00:47:32,700
當你touch到s的時候

1479
00:47:32,700 --> 00:47:34,700
那你就是結束了

1480
00:47:34,700 --> 00:47:36,700
那在這個過程

1481
00:47:36,700 --> 00:47:38,700
你就可以從尾巴

1482
00:47:38,700 --> 00:47:40,700
這樣子把它印出來

1483
00:47:40,700 --> 00:47:42,700
好 

1484
00:47:42,700 --> 00:47:44,700
所以以上是BFS的說明

1485
00:47:44,700 --> 00:47:46,700
謝謝大家

1486
00:47:46,700 --> 00:47:48,700
謝謝

