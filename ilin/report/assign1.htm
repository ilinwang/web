<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>First Method</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.01Gold (X11; I; SunOS 5.5 sun4m) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#D9D9F3" LINK="#0000FF" VLINK="#00008B">

<H2 ALIGN=CENTER><FONT SIZE=+3>First Method</FONT><FONT SIZE=+2>:</FONT></h2>
<center><h4><i><font color=darkgreen>This page was updated by
  <script language="LiveScript">

  <!--  hide script from old browsers

    document.writeln(document.lastModified+'<br>')

  // end hiding contents -->

 document.writeln('Please '+'<b><font color=black>reload</font></b> often to get the updated information');
  </script>
</font></i></h4><hr></center>
<H3><FONT SIZE=+2><B>0.Generate Demand Matrix D, Network G:</B> </FONT></H3>

<P>We can use <A HREF="../ilin/generators.html">network generator</A> (netgen,
gridgen) to do this. </P>

<P>How: <BR>
We have to define: </P>

<UL>
<P><B>no. nodes/arcs <BR>
max/min capacity/cost/demand </B></P>
</UL>

<P>the network generated by the software may look nonsense sometimes. </P>

<H3><FONT SIZE=+2><B>1.Graph Transformation:</B> </FONT></H3>

<P>assign each link 1 fiber; <BR>
each fiber can handle n wavelengths; <BR>
No_of_Stage=1 <BR>
duplicate n virtual network, each represents 1 wavelength <BR>
<B>for</B> each virtual network </P>

<UL>
<P>cost of an arc : 1 (if we want to min # hops) or distance (if we want
to min length of connection) <BR>
capacity: 1 , initially.</P>
</UL>

<H3><B><FONT SIZE=+2>2.Main procedures of the Algorithm:</FONT></B><BR>

<HR></H3>

<CENTER><TABLE ALIGN=ABSCENTER BORDER=1 CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFFF" >
<TR>
<TD>Sort demands in descending order (big-&gt;small) <BR>
<B>for </B>each demand dij 
<UL>
<B><I>findPATH(dij);<BR>
</I>if </B>return yes, <B>then </B>end current loop, goto next dij<BR>
<B>else </B>

<UL>
increase 1 for all the capacity of each arc in these n virtual networks
<BR>
<B><I>findPATH(dij)</I></B>;(we will always find one rout if we add capacity)
<BR>
No_of_Stage ++ 
</UL>
</UL>
</TD>
</TR>
</TABLE></CENTER>

<P>
<HR></P>

<CENTER><TABLE ALIGN=ABSCENTER BORDER=1 CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFFF" >
<TR>
<TD><B><I>findPATH(d<SUB>ij</SUB>)</I></B>: <BR>
Now this is a min-cost flow problem, we have to satisfy the capacity constraint
and find a path which can send out this flow with min-cost. <BR>
We can use <A HREF="../ilin/simplexcode.html">Network Simplex Algorithm</A>
to solve this problem. 
<OL>
<LI>create new virtual source/sink nodes <BR>
create virtual arcs from that virtual source to all the corresponding source
nodes in each virtual network <BR>
create virtual arcs from all the corresponding sink nodes in each virtual
network to that virtual sink <BR>
all virtual arcs have 0 cost and no capacity constraints. <BR>
</LI>

<LI><B>If </B>we can send this flow by the algorithm </LI>

<OL>
<P>assign this path to dij <BR>
decrease capacity of all the arcs lying on this path by 1 <BR>
return yes 
</OL>

<B>else </B>

<OL>
return no
</OL>
</OL>
</TD>
</TR>
</TABLE></CENTER>

<P><BR>
<FONT SIZE=+2><B>3.Truncate unused fiber:</B> </FONT></P>

<P><B>for </B>each link l in physical network </P>

<UL>
<P>scan for the corresponding link l in all n virtual networks <BR>
delete min{capacity[i,l]} for all i=1~n</P>

<UL>
<P>where capacity[i,l] represents the capacity of link l in <BR>
virtual network i (for ith wavelength) </P>
</UL>
</UL>

<P>
<HR></P>

<P><B><FONT SIZE=+2>Advantage</FONT></B>: </P>

<OL>
<LI>Easy to implement:<BR>
a. I got network generators software already <BR>
b. I got network simplex solver software already(but I may need to modify
the codes) <BR>
c. Whenever we can't assign a path, we just add fiber, easy. <BR>
d. Easy to detect unused fiber and delete them. </LI>

<LI>It will globally search for the shortest path for all the wavelengths
in all the fibers without violating the constrain that every wavelength
must be different with each other. </LI>

<LI>We add capacity for new stage instead of adding new arc, which maintains
a fixed topology. </LI>

<LI>Using this method, it is very convenient to solve the switching wavelength
problem when we want to trucate the unused fiber. Because this method superpositions
the # fibers for a link by increasing capacity.</LI>
</OL>

<P><B><FONT SIZE=+2>Disadvantage</FONT></B>: </P>

<OL>
<LI>Each time when we add fiber, we have to add 1 more fiber on all the
arcs. <BR>
a. Which means, we may waste too many fibers. <BR>
b. for the first few stages, this method may perform well, because it will
try to average the traffic till it really can't find a connection. However,
in the last few stages, the fibers may not be used very effectively. <BR>
For example, many fibers may only be used by 1 or 2 wavelengths even if
there are 7 or 6 channels available. <BR>
c. Since this method tends to average the traffic topologically, there
may be some paths look a little nonsense. This is also due to the equal
weight of adding new fibers to all the links. </LI>

<LI>We only use heuristics here, because we have to satisfy all the demands.<BR>
</LI>
</OL>

<H3><B><FONT SIZE=+2>Comments</FONT></B><FONT SIZE=+0>: </FONT></H3>

<OL>
<LI>In fact, this problem is a network design problem. In my 1st algorithm,
I use equal weight to add fibers to all the link whenever one demands can't
be satisfied by current netowrk. <BR>
This method has advantage of averaging the traffic demands. On the other
hand, adding same fiber to each link has bad flexibility. </LI>

<LI>Since we can't predict how the demands will distributed around the
network geographically in advance, in the 1st several stages, it's very
reasonable to assume all link has equal numbers of fibers. <BR>
However, when we are going to finish assigning paths for demands, we should
try not to add fibers equally to each link. In stead, some method which
can dynamically sense better arcs to be added fibers should be applied.<BR>
</LI>
</OL>

<P><B><FONT SIZE=+2>Options</FONT></B>: </P>

<ol><li>Combine 2 algorithms: <BR>
after we satisfied an enough amount of demands, say, 2/3(total demands),
then, when we find we can't satisfy a demand, we put it into a queue, and
keep going, without adding more fibers. <BR>
Till we have finished scaning all the demands, we will start to assign
new fibers only for those demands in that queue. <BR>
We may have several ways to do the 2nd part, so far, I haven't had a good
idea about how to do this. Basically it's because we don't know how the
demands will distributed. </P>

<li>Another way is to use our original algorithm to finish the assignment,
then, identify those fibers with small used ratio, and delete them, see
how many demands have to be reassigned paths, and add some more new fibers
to some arcs only. <BR>
Again, how to choose the demands to rerouting is hard. One reason is that
we may/(may not) add fibers to do so; when we want to add fibers, where
to add so that we can save some cost is also unknown. </P>
</ol>
<H3><B><FONT SIZE=+2>Conclusion</FONT></B><FONT SIZE=+0>: </FONT></H3>
<ul><li>I will start using the 1st algorithm only now. </P>
</ul>
<CENTER><P><IMG SRC="./gif/assign1.gif" HEIGHT=376 WIDTH=441> </P></CENTER>

</BODY>
</HTML>
